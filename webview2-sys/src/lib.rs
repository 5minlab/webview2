//! Low Level Bindings for WebView2 SDK.
#![cfg(windows)]
#![allow(clippy::missing_safety_doc, non_snake_case)]

// Generated by idl2rs.

use com::{
    com_interface,
    interfaces::{iunknown::IUnknownVTable, IUnknown},
};
use std::ffi::c_void;
use winapi::shared::basetsd::*;
use winapi::shared::minwindef::{ULONG, *};
use winapi::shared::ntdef::*;
use winapi::shared::windef::*;
use winapi::um::oaidl::VARIANT;
use winapi::um::objidlbase::STATSTG;

/// Represents a reference to a delegate that receives change notifications.
#[repr(C)]
#[derive(Debug, Eq, PartialEq, Copy, Clone)]
pub struct EventRegistrationToken {
    value: i64,
}

#[com_interface("0c733a30-2a1c-11ce-ade5-00aa0044773d")]
pub trait ISequentialStream: IUnknown {
    unsafe fn read(&self, pv: *mut c_void, cb: ULONG, pcbRead: *mut ULONG) -> HRESULT;
    unsafe fn write(&self, pv: *const c_void, cb: ULONG, pcbWritten: *mut ULONG) -> HRESULT;
}

#[com_interface("0000000c-0000-0000-C000-000000000046")]
pub trait IStream: ISequentialStream {
    unsafe fn seek(
        &self,
        dlibMove: LARGE_INTEGER,
        dwOrigin: DWORD,
        plibNewPosition: *mut ULARGE_INTEGER,
    ) -> HRESULT;
    unsafe fn set_size(&self, libNewSize: ULARGE_INTEGER) -> HRESULT;
    unsafe fn copy_to(
        &self,
        pstm: *mut *mut IStreamVTable,
        cb: ULARGE_INTEGER,
        pcbRead: *mut ULARGE_INTEGER,
        pcbWritten: *mut ULARGE_INTEGER,
    ) -> HRESULT;
    unsafe fn commit(&self, grfCommitFlags: DWORD) -> HRESULT;
    unsafe fn revert(&self) -> HRESULT;
    unsafe fn lock_region(
        &self,
        libOffset: ULARGE_INTEGER,
        cb: ULARGE_INTEGER,
        dwLockType: DWORD,
    ) -> HRESULT;
    unsafe fn unlock_region(
        &self,
        libOffset: ULARGE_INTEGER,
        cb: ULARGE_INTEGER,
        dwLockType: DWORD,
    ) -> HRESULT;
    unsafe fn stat(&self, pstatstg: *mut STATSTG, grfStatFlag: DWORD) -> HRESULT;
    unsafe fn clone(&self, ppstm: *mut *mut *mut IStreamVTable) -> HRESULT;
}

/// DLL export to create a WebView2 environment with a custom version of Edge,
/// user data directory and/or additional browser switches.
///
/// browserExecutableFolder is the relative path to the folder that
/// contains the embedded Edge. The embedded Edge can be obtained by
/// copying the version named folder of an installed Edge, like
/// 73.0.52.0 sub folder of an installed 73.0.52.0 Edge. The folder
/// should have msedge.exe, msedge.dll, etc.
/// Use null or empty string for browserExecutableFolder to create
/// WebView using Edge installed on the machine, in which case the
/// API will try to find a compatible version of Edge installed on the
/// machine according to the channel preference trying to find first
/// per user install and then per machine install.
///
/// The default channel search order is stable, beta, dev, and canary.
/// When there is an override WEBVIEW2_RELEASE_CHANNEL_PREFERENCE environment
/// variable or applicable releaseChannelPreference registry value
/// with the value of 1, the channel search order is reversed.
///
/// userDataFolder can be
/// specified to change the default user data folder location for
/// WebView2. The path can be an absolute file path or a relative file path
/// that is interpreted as relative to the current process's executable.
/// Otherwise, for UWP apps, the default user data folder will be
/// the app data folder for the package; for non-UWP apps,
/// the default user data folder `{Executable File Name}.WebView2`
/// will be created in the same directory next to the app executable.
/// WebView2 creation can fail if the executable is running in a directory
/// that the process doesn't have permission to create a new folder in.
/// The app is responsible to clean up its user data folder
/// when it is done.
///
/// additionalBrowserArguments can be specified to change the behavior of the
/// WebView. These will be passed to the browser process as part of
/// the command line. See
/// [Run Chromium with Flags](https://aka.ms/RunChromiumWithFlags)
/// for more information about command line switches to browser
/// process. If the app is launched with a command line switch
/// `--edge-webview-switches=xxx` the value of that switch (xxx in
/// the above example) will also be appended to the browser
/// process command line. Certain switches like `--user-data-dir` are
/// internal and important to WebView. Those switches will be
/// ignored even if specified. If the same switches are specified
/// multiple times, the last one wins. Note that this also applies
/// to switches like `--enable-features`. There is no attempt to
/// merge the different values of the same switch. App process's
/// command line `--edge-webview-switches` value are processed after
/// the additionalBrowserArguments parameter is processed.
/// Also note that as a browser process might be shared among
/// WebViews, the switches are not guaranteed to be applied except
/// for the first WebView that starts the browser process.
/// If parsing failed for the specified switches, they will be
/// ignored. `nullptr` will run browser process with no flags.
///
/// environment_created_handler is the handler result to the async operation
/// which will contain the WebView2Environment that got created.
///
/// The browserExecutableFolder, userDataFolder and additionalBrowserArguments
/// members of the environmentParams may be overridden by
/// values either specified in environment variables or in the registry.
///
/// When creating a WebView2Environment the following environment variables
/// are checked:
///
/// ```
/// WEBVIEW2_BROWSER_EXECUTABLE_FOLDER
/// WEBVIEW2_USER_DATA_FOLDER
/// WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS
/// WEBVIEW2_RELEASE_CHANNEL_PREFERENCE
/// ```
///
/// If an override environment variable is found then we use the
/// browserExecutableFolder, userDataFolder and additionalBrowserArguments
/// values as replacements for the corresponding values in
/// CreateCoreWebView2EnvironmentWithDetails parameters.
///
/// While not strictly overrides, there exists additional environment variables
/// that can be set:
///
/// ```
/// WEBVIEW2_WAIT_FOR_SCRIPT_DEBUGGER
/// ```
///
/// When found with a non-empty value, this indicates that the WebView is being
/// launched under a script debugger. In this case, the WebView will issue a
/// `Page.waitForDebugger` CDP command that will cause script execution inside the
/// WebView to pause on launch, until a debugger issues a corresponding
/// `Runtime.runIfWaitingForDebugger` CDP command to resume execution.
/// Note: There is no registry key equivalent of this environment variable.
///
/// ```
/// WEBVIEW2_PIPE_FOR_SCRIPT_DEBUGGER
/// ```
///
/// When found with a non-empty value, this indicates that the WebView is being
/// launched under a script debugger that also supports host applications that
/// use multiple WebViews. The value is used as the identifier for a named pipe
/// that will be opened and written to when a new WebView is created by the host
/// application. The payload will match that of the remote-debugging-port JSON
/// target and can be used by the external debugger to attach to a specific
/// WebView instance.
/// The format of the pipe created by the debugger should be:
/// `\\.\pipe\WebView2\Debugger\{app_name}\{pipe_name}`
/// where:
///
/// - `{app_name}` is the host application exe filename, e.g. WebView2Example.exe
/// - `{pipe_name}` is the value set for WEBVIEW2_PIPE_FOR_SCRIPT_DEBUGGER.
///
/// To enable debugging of the targets identified by the JSON you will also need
/// to set the WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS environment variable to
/// send `--remote-debugging-port={port_num}`
/// where:
///
/// - `{port_num}` is the port on which the CDP server will bind.
///
/// Be aware that setting both the WEBVIEW2_PIPE_FOR_SCRIPT_DEBUGGER and
/// WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS environment variables will cause the
/// WebViews hosted in your application and their contents to be exposed to
/// 3rd party applications such as debuggers.
///
/// Note: There is no registry key equivalent of this environment variable.
///
/// If none of those environment variables exist, then the registry is examined next.
/// The following registry keys are checked:
///
/// ```
/// [{Root}\Software\Policies\Microsoft\EmbeddedBrowserWebView\LoaderOverride\{AppId}]
/// "releaseChannelPreference"=dword:00000000
/// "browserExecutableFolder"=""
/// "userDataFolder"=""
/// "additionalBrowserArguments"=""
/// ```
///
/// In the unlikely scenario where some instances of WebView are open during
/// a browser update we could end up blocking the deletion of old Edge browsers.
/// To avoid running out of disk space a new WebView creation will fail
/// with the next error if it detects that there are many old versions present.
///
/// ```
/// ERROR_DISK_FULL
/// ```
///
/// The default maximum number of Edge versions allowed is 20.
///
/// The maximum number of old Edge versions allowed can be overwritten with the value
/// of the following environment variable.
///
/// ```
/// WEBVIEW2_MAX_INSTANCES
/// ```
///
/// If the Webview depends on an installed Edge and it is uninstalled
/// any subsequent creation will fail with the next error
///
/// ```
/// ERROR_PRODUCT_UNINSTALLED
/// ```
///
/// First we check with Root as HKLM and then HKCU.
/// AppId is first set to the Application User Model ID of the caller's process,
/// then if there's no corresponding registry key the AppId is
/// set to the executable name of the caller's process, or if that
/// isn't a registry key then '*'. If an override registry key is found then we
/// use the browserExecutableFolder, userDataFolder and additionalBrowserArguments
/// registry values as replacements for the corresponding values in
/// CreateCoreWebView2EnvironmentWithDetails parameters. If any of those registry values
/// isn't present, then the parameter passed to CreateCoreWebView2Environment is used.
pub type FnCreateCoreWebView2EnvironmentWithDetails = unsafe extern "stdcall" fn(browserExecutableFolder: PCWSTR, userDataFolder: PCWSTR, additionalBrowserArguments: PCWSTR, environment_created_handler: *mut *mut ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandlerVTable) -> HRESULT;
/// WebView2 enables you to host web content using the
/// latest Edge web browser technology.
///
/// ## Navigation events
/// The normal sequence of navigation events is NavigationStarting,
/// SourceChanged, ContentLoading and then NavigationCompleted.
///
/// \dot
/// digraph NavigationEvents {
///    node [fontname=Roboto, shape=rectangle]
///    edge [fontname=Roboto]
///
///    NewDocument -> NavigationStarting;
///    NavigationStarting -> SourceChanged -> ContentLoading [label="New Document"];
///    ContentLoading -> HistoryChanged;
///    SameDocument -> SourceChanged;
///    SourceChanged -> HistoryChanged [label="Same Document"];
///    HistoryChanged -> NavigationCompleted;
///    NavigationStarting -> NavigationStarting [label="Redirect"];
///    NavigationStarting -> NavigationCompleted [label="Failure"];
/// }
/// \enddot
///
/// Note that this is for navigation events with the same NavigationId event
/// arg. Navigations events with different NavigationId event args may overlap.
/// For instance, if you start a navigation wait for its NavigationStarting
/// event and then start another navigation you'll see the NavigationStarting
/// for the first navigate followed by the NavigationStarting of the second
/// navigate, followed by the NavigationCompleted for the first navigation and
/// then all the rest of the appropriate navigation events for the second
/// navigation.
/// In error cases there may or may not be a ContentLoading event depending
/// on whether the navigation is continued to an error page.
/// In case of an HTTP redirect, there will be multiple NavigationStarting
/// events in a row, with ones following the first will have their IsRedirect
/// flag set.
///
/// To monitor or cancel navigations inside subframes in the WebView, use
/// FrameNavigationStarting.
///
/// ## Process model
/// WebView2 uses the same process model as the Edge web
/// browser. There is one Edge browser process per specified user data directory
/// in a user session that will serve any WebView2 calling
/// process that specifies that user data directory. This means one Edge browser
/// process may be serving multiple calling processes and one calling
/// process may be using multiple Edge browser processes.
///
/// \dot
/// digraph ProcessModelNClientsNServers {
///     node [fontname=Roboto, shape=rectangle];
///     edge [fontname=Roboto];
///
///     Host1 [label="Calling\nprocess 1"];
///     Host2 [label="Calling\nprocess 2"];
///     Browser1 [label="Edge processes\ngroup 1"];
///     Browser2 [label="Edge processes\ngroup 2"];
///
///     Host1 -> Browser1;
///     Host1 -> Browser2;
///     Host2 -> Browser2;
/// }
/// \enddot
///
/// Off of a browser process there will be some number of renderer processes.
/// These are created as
/// necessary to service potentially multiple frames in different WebViews. The
/// number of renderer processes varies based on the site isolation browser
/// feature and the number of distinct disconnected origins rendered in
/// associated WebViews.
///
/// \dot
/// digraph ProcessModelClientServer {
///     node [fontname=Roboto, shape=rectangle];
///     edge [fontname=Roboto];
///     graph [fontname=Roboto];
///
///     Host [label="Calling process"];
///     subgraph cluster_0 {
///         labeljust = "l";
///         label = "Edge processes group";
///         Browser [label="Edge browser\nprocess"];
///         Render1 [label="Edge render\nprocess 1"];
///         Render2 [label="Edge render\nprocess 2"];
///         RenderN [label="Edge render\nprocess N"];
///         GPU [label="Edge GPU\nprocess"];
///     }
///
///     Host -> Browser;
///     Browser -> Render1;
///     Browser -> Render2;
///     Browser -> RenderN;
///     Browser -> GPU;
/// }
/// \enddot
///
/// You can react to crashes and hangs in these browser and renderer processes
/// using the ProcessFailure event.
///
/// You can safely shutdown associated browser and renderer processes using the
/// Close method.
///
/// ## Threading model
/// The WebView2 must be created on a UI thread. Specifically a
/// thread with a message pump. All callbacks will occur on that thread and
/// calls into the WebView must be done on that thread. It is not safe to use
/// the WebView from another thread.
///
/// Callbacks including event handlers and completion handlers execute serially.
/// That is, if you have an event handler running and begin a message loop no
/// other event handlers or completion callbacks will begin executing
/// reentrantly.
///
/// ## Security
/// Always check the Source property of the WebView before using ExecuteScript,
/// PostWebMessageAsJson, PostWebMessageAsString, or any other method to send
/// information into the WebView. The WebView may have navigated to another page
/// via the end user interacting with the page or script in the page causing
/// navigation. Similarly, be very careful with
/// AddScriptToExecuteOnDocumentCreated. All future navigations will run this
/// script and if it provides access to information intended only for a certain
/// origin, any HTML document may have access.
///
/// When examining the result of an ExecuteScript method call, a
/// WebMessageReceived event, always check the Source of the sender, or any
/// other mechanism of receiving information from an HTML document in a WebView
/// validate the URI of the HTML document is what you expect.
///
/// When constructing a message to send into a WebView, prefer using
/// PostWebMessageAsJson and construct the JSON string parameter using a JSON
/// library. This will avoid any potential accidents of encoding information
/// into a JSON string or script and ensure no attacker controlled input can
/// modify the rest of the JSON message or run arbitrary script.
///
/// ## String types
/// String out parameters are LPWSTR null terminated strings. The callee
/// allocates the string using CoTaskMemAlloc. Ownership is transferred to the
/// caller and it is up to the caller to free the memory using CoTaskMemFree.
///
/// String in parameters are LPCWSTR null terminated strings. The caller ensures
/// the string is valid for the duration of the synchronous function call.
/// If the callee needs to retain that value to some point after the function
/// call completes, the callee must allocate its own copy of the string value.
///
/// ## URI and JSON parsing
/// Various methods provide or accept URIs and JSON as strings. Please use your
/// own preferred library for parsing and generating these strings.
///
/// If WinRT is available for your app you can use `RuntimeClass_Windows_Data_Json_JsonObject`
/// and `IJsonObjectStatics` to parse or produce JSON strings or `RuntimeClass_Windows_Foundation_Uri`
/// and `IUriRuntimeClassFactory` to parse and produce URIs. Both of these work
/// in Win32 apps.
///
/// If you use IUri and CreateUri to parse URIs you may want to use the
/// following URI creation flags to have CreateUri behavior more closely match
/// the URI parsing in the WebView:
/// `Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME | Uri_CREATE_NO_DECODE_EXTRA_INFO`
///
/// ## Debugging
/// Open DevTools with the normal shortcuts: `F12` or `Ctrl+Shift+I`.
/// You can use the `--auto-open-devtools-for-tabs` command argument switch to
/// have the DevTools window open immediately when first creating a WebView. See
/// CreateCoreWebView2Host documentation for how to provide additional command
/// line arguments to the browser process.
/// Check out the LoaderOverride registry key for trying out different builds of
/// WebView2 without modifying your application in the CreateCoreWebView2Host
/// documentation.
///
/// ## Versioning
/// After you've used a particular version of the SDK to build your app, your
/// app may end up running with an older or newer version of installed browser
/// binaries. Until version 1.0.0.0 of WebView2 there may be breaking changes
/// during updates that will prevent your SDK from working with different
/// versions of installed browser binaries. After version 1.0.0.0 different
/// versions of the SDK can work with different versions of the installed
/// browser by following these best practices:
///
/// To account for breaking changes to the API be sure to check for failure when
/// calling the DLL export CreateCoreWebView2Environment and when
/// calling QueryInterface on any CoreWebView2 object. A return value of
/// E_NOINTERFACE can indicate the SDK is not compatible with the Edge
/// browser binaries.
///
/// Checking for failure from QueryInterface will also account for cases where
/// the SDK is newer than the version of the Edge browser and your app attempts
/// to use an interface of which the Edge browser is unaware.
///
/// When an interface is unavailable, you can consider disabling the associated
/// feature if possible, or otherwise informing the end user they need to update
/// their browser.
#[com_interface("5cc5293d-af6f-41d4-9619-44bd31ba4c93")]
pub trait ICoreWebView2: IUnknown {
    /// The ICoreWebView2Settings object contains various modifiable settings for
    /// the running WebView.
    unsafe fn get_settings(
        &self,
        /* out, retval */ settings: *mut *mut *mut ICoreWebView2SettingsVTable,
    ) -> HRESULT;

    /// The URI of the current top level document. This value potentially
    /// changes as a part of the SourceChanged event firing for some cases
    /// such as navigating to a different site or fragment navigations. It will
    /// remain the same for other types of navigations such as page reloads or
    /// history.pushState with the same URL as the current page.
    ///
    /// \snippet ControlComponent.cpp SourceChanged
    unsafe fn get_source(&self, /* out, retval */ uri: *mut LPWSTR) -> HRESULT;

    /// Cause a navigation of the top level document to the specified URI. See
    /// the navigation events for more information. Note that this starts a
    /// navigation and the corresponding NavigationStarting event will fire
    /// sometime after this Navigate call completes.
    ///
    /// \snippet ControlComponent.cpp Navigate
    unsafe fn navigate(&self, /* in */ uri: LPCWSTR) -> HRESULT;

    /// Initiates a navigation to htmlContent as source HTML of a new
    /// document. The htmlContent parameter may not be larger than 2 MB of
    /// characters. The origin of the new page will be about:blank.
    ///
    /// \snippet SettingsComponent.cpp NavigateToString
    unsafe fn navigate_to_string(&self, /* in */ html_content: LPCWSTR) -> HRESULT;

    /// Add an event handler for the NavigationStarting event.
    /// NavigationStarting fires when the WebView main frame is
    /// requesting permission to navigate to a different URI. This will fire for
    /// redirects as well.
    ///
    /// \snippet SettingsComponent.cpp NavigationStarting
    unsafe fn add_navigation_starting(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2NavigationStartingEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_NavigationStarting.
    unsafe fn remove_navigation_starting(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the ContentLoading event.
    /// ContentLoading fires before any content is loaded, including scripts added with
    /// AddScriptToExecuteOnDocumentCreated
    /// ContentLoading will not fire if a same page navigation occurs
    /// (such as through fragment navigations or history.pushState navigations).
    /// This follows the NavigationStarting and SourceChanged events and
    /// precedes the HistoryChanged and NavigationCompleted events.
    unsafe fn add_content_loading(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2ContentLoadingEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_ContentLoading.
    unsafe fn remove_content_loading(&self, /* in */ token: EventRegistrationToken) -> HRESULT;

    /// SourceChanged fires when the Source property changes.
    /// SourceChanged fires for navigating to a different site or fragment navigations.
    /// It will not fires for other types of navigations such as page reloads or
    /// history.pushState with the same URL as the current page.
    /// SourceChanged fires before ContentLoading for navigation to a new document.
    /// Add an event handler for the SourceChanged event.
    /// \snippet ControlComponent.cpp SourceChanged
    unsafe fn add_source_changed(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2SourceChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_SourceChanged.
    unsafe fn remove_source_changed(&self, /* in */ token: EventRegistrationToken) -> HRESULT;

    /// HistoryChange listen to the change of navigation history for the top level
    /// document. Use HistoryChange to check if get_CanGoBack/get_CanGoForward value
    /// has changed. HistoryChanged also fires for using GoBack/GoForward.
    /// HistoryChanged fires after SourceChanged and ContentLoading.
    /// Add an event handler for the HistoryChanged event.
    /// \snippet ControlComponent.cpp HistoryChanged
    unsafe fn add_history_changed(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2HistoryChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_HistoryChanged.
    unsafe fn remove_history_changed(&self, /* in */ token: EventRegistrationToken) -> HRESULT;

    /// Add an event handler for the NavigationCompleted event.
    /// NavigationCompleted event fires when the WebView has completely loaded
    /// (body.onload has fired) or loading stopped with error.
    ///
    /// \snippet ControlComponent.cpp NavigationCompleted
    unsafe fn add_navigation_completed(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2NavigationCompletedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_NavigationCompleted.
    unsafe fn remove_navigation_completed(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the FrameNavigationStarting event.
    /// FrameNavigationStarting fires when a child frame in the WebView
    /// requesting permission to navigate to a different URI. This will fire for
    /// redirects as well.
    ///
    /// \snippet SettingsComponent.cpp FrameNavigationStarting
    unsafe fn add_frame_navigation_starting(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2NavigationStartingEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_FrameNavigationStarting.
    unsafe fn remove_frame_navigation_starting(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the ScriptDialogOpening event.
    /// The event fires when a JavaScript dialog (alert, confirm, or prompt) will
    /// show for the webview. This event only fires if the
    /// ICoreWebView2Settings::AreDefaultScriptDialogsEnabled property is set to
    /// false. The ScriptDialogOpening event can be used to suppress dialogs or
    /// replace default dialogs with custom dialogs.
    ///
    /// \snippet SettingsComponent.cpp ScriptDialogOpening
    unsafe fn add_script_dialog_opening(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2ScriptDialogOpeningEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_ScriptDialogOpening.
    unsafe fn remove_script_dialog_opening(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the PermissionRequested event.
    /// Fires when content in a WebView requests permission to access some
    /// privileged resources.
    ///
    /// \snippet SettingsComponent.cpp PermissionRequested
    unsafe fn add_permission_requested(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2PermissionRequestedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_PermissionRequested.
    unsafe fn remove_permission_requested(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the ProcessFailed event.
    /// Fires when a WebView process terminated unexpectedly or
    /// become unresponsive.
    ///
    /// \snippet ProcessComponent.cpp ProcessFailed
    unsafe fn add_process_failed(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2ProcessFailedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_ProcessFailed.
    unsafe fn remove_process_failed(&self, /* in */ token: EventRegistrationToken) -> HRESULT;

    /// Add the provided JavaScript to a list of scripts
    /// that should be executed after the global object has been created, but
    /// before the HTML document has been parsed and before any other script
    /// included by the HTML document is executed. The
    /// injected script will apply to all future top level document and child
    /// frame navigations until removed with RemoveScriptToExecuteOnDocumentCreated.
    /// This is applied asynchronously and you must wait for the completion
    /// handler to run before you can be sure that the script is ready to
    /// execute on future navigations.
    ///
    /// Note that if an HTML document has sandboxing of some kind via [sandbox](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox)
    /// properties or the [Content-Security-Policy HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
    /// this will affect the script run here. So, for example, if the
    /// 'allow-modals' keyword is not set then calls to the `alert` function will
    /// be ignored.
    ///
    /// \snippet ScriptComponent.cpp AddScriptToExecuteOnDocumentCreated
    unsafe fn add_script_to_execute_on_document_created(
        &self,
        /* in */ java_script: LPCWSTR,
        /* in */
        handler: *mut *mut ICoreWebView2AddScriptToExecuteOnDocumentCreatedCompletedHandlerVTable,
    ) -> HRESULT;

    /// Remove the corresponding JavaScript added via AddScriptToExecuteOnDocumentCreated.
    unsafe fn remove_script_to_execute_on_document_created(
        &self,
        /* in */ id: LPCWSTR,
    ) -> HRESULT;

    /// Execute JavaScript code from the javascript parameter in the
    /// current top level document rendered in the WebView. This will execute
    /// asynchronously and when complete, if a handler is provided in the
    /// ExecuteScriptCompletedHandler parameter, its Invoke method will be
    /// called with the result of evaluating the provided JavaScript. The result
    /// value is a JSON encoded string.
    /// If the result is undefined, contains a reference cycle, or otherwise
    /// cannot be encoded into JSON, the JSON null value will be returned as the
    /// string 'null'. Note that a function that has no explicit return value
    /// returns undefined.
    /// If the executed script throws an unhandled exception, then the result is
    /// also 'null'.
    /// This method is applied asynchronously. If the call is made while the
    /// webview is on one document, and a navigation occurs after the call is
    /// made but before the JavaScript is executed, then the script will not be
    /// executed and the handler will be called with E_FAIL for its errorCode
    /// parameter.
    /// ExecuteScript will work even if IsScriptEnabled is set to FALSE.
    ///
    /// \snippet ScriptComponent.cpp ExecuteScript
    unsafe fn execute_script(
        &self,
        /* in */ java_script: LPCWSTR,
        /* in */ handler: *mut *mut ICoreWebView2ExecuteScriptCompletedHandlerVTable,
    ) -> HRESULT;

    /// Capture an image of what WebView is displaying. Specify the
    /// format of the image with the imageFormat parameter.
    /// The resulting image binary data is written to the provided imageStream
    /// parameter. When CapturePreview finishes writing to the stream, the Invoke
    /// method on the provided handler parameter is called.
    ///
    /// \snippet FileComponent.cpp CapturePreview
    unsafe fn capture_preview(
        &self,
        /* in */ image_format: CapturePreviewImageFormat,
        /* in */ image_stream: *mut *mut IStreamVTable,
        /* in */ handler: *mut *mut ICoreWebView2CapturePreviewCompletedHandlerVTable,
    ) -> HRESULT;

    /// Reload the current page. This is similar to navigating to the URI of
    /// current top level document including all navigation events firing and
    /// respecting any entries in the HTTP cache. But, the back/forward history
    /// will not be modified.
    unsafe fn reload(&self) -> HRESULT;

    /// Post the specified webMessage to the top level document in this WebView.
    /// The top level document's window.chrome.webview's message event fires.
    /// JavaScript in that document may subscribe and unsubscribe to the event
    /// via the following:
    /// ```
    ///    window.chrome.webview.addEventListener('message', handler)
    ///    window.chrome.webview.removeEventListener('message', handler)
    /// ```
    /// The event args is an instance of `MessageEvent`.
    /// The ICoreWebView2Settings::IsWebMessageEnabled setting must be true or this method
    /// will fail with E_INVALIDARG.
    /// The event arg's data property is the webMessage string parameter parsed
    /// as a JSON string into a JavaScript object.
    /// The event arg's source property is a reference to the
    /// `window.chrome.webview` object.
    /// See SetWebMessageReceivedEventHandler for information on sending messages
    /// from the HTML document in the webview to the host.
    /// This message is sent asynchronously. If a navigation occurs before the
    /// message is posted to the page, then the message will not be sent.
    ///
    /// \snippet ScenarioWebMessage.cpp WebMessageReceived
    unsafe fn post_web_message_as_json(
        &self,
        /* in */ web_message_as_json: LPCWSTR,
    ) -> HRESULT;

    /// This is a helper for posting a message that is a simple string
    /// rather than a JSON string representation of a JavaScript object. This
    /// behaves in exactly the same manner as PostWebMessageAsJson but the
    /// `window.chrome.webview` message event arg's data property will be a string
    /// with the same value as webMessageAsString. Use this instead of
    /// PostWebMessageAsJson if you want to communicate via simple strings rather
    /// than JSON objects.
    unsafe fn post_web_message_as_string(
        &self,
        /* in */ web_message_as_string: LPCWSTR,
    ) -> HRESULT;

    /// This event fires when the IsWebMessageEnabled setting is set and the top
    /// level document of the webview calls `window.chrome.webview.postMessage`.
    /// The postMessage function is `void postMessage(object)` where
    /// object is any object supported by JSON conversion.
    ///
    /// \snippet ScenarioWebMessage.html chromeWebView
    ///
    /// When postMessage is called, the ICoreWebView2WebMessageReceivedEventHandler set via
    /// this SetWebMessageReceivedEventHandler method will be invoked with the
    /// postMessage's object parameter converted to a JSON string.
    ///
    /// \snippet ScenarioWebMessage.cpp WebMessageReceived
    unsafe fn add_web_message_received(
        &self,
        /* in */ handler: *mut *mut ICoreWebView2WebMessageReceivedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_WebMessageReceived.
    unsafe fn remove_web_message_received(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Call an asynchronous DevToolsProtocol method. See the
    /// [DevTools Protocol Viewer](https://aka.ms/DevToolsProtocolDocs)
    /// for a list and description of available methods.
    /// The methodName parameter is the full name of the method in the format
    /// `{domain}.{method}`.
    /// The parametersAsJson parameter is a JSON formatted string containing
    /// the parameters for the corresponding method.
    /// The handler's Invoke method will be called when the method asynchronously
    /// completes. Invoke will be called with the method's return object as a
    /// JSON string.
    ///
    /// \snippet ScriptComponent.cpp CallDevToolsProtocolMethod
    unsafe fn call_dev_tools_protocol_method(
        &self,
        /* in */ method_name: LPCWSTR,
        /* in */ parameters_as_json: LPCWSTR,
        /* in */
        handler: *mut *mut ICoreWebView2CallDevToolsProtocolMethodCompletedHandlerVTable,
    ) -> HRESULT;

    /// The process id of the browser process that hosts the WebView.
    unsafe fn get_browser_process_id(&self, /* out, retval */ value: *mut UINT32) -> HRESULT;

    /// Returns true if the webview can navigate to a previous page in the navigation history.
    /// The HistoryChanged event will fire if get_CanGoBack changes value.
    unsafe fn get_can_go_back(&self, /* out, retval */ can_go_back: *mut BOOL) -> HRESULT;

    /// Returns true if the webview can navigate to a next page in the navigation history.
    /// The HistoryChanged event will fire if get_CanGoForward changes value.
    unsafe fn get_can_go_forward(
        &self,
        /* out, retval */ can_go_forward: *mut BOOL,
    ) -> HRESULT;

    /// Navigates the WebView to the previous page in the navigation history.
    unsafe fn go_back(&self) -> HRESULT;

    /// Navigates the WebView to the next page in the navigation history.
    unsafe fn go_forward(&self) -> HRESULT;

    /// Get a DevTools Protocol event receiver that allows you to subscribe to
    /// a DevTools Protocol event.
    /// The eventName parameter is the full name of the event in the format
    /// `{domain}.{event}`.
    /// See the [DevTools Protocol Viewer](https://aka.ms/DevToolsProtocolDocs)
    /// for a list of DevTools Protocol events description, and event args.
    ///
    /// \snippet ScriptComponent.cpp DevToolsProtocolEventReceived
    unsafe fn get_dev_tools_protocol_event_receiver(
        &self,
        /* in */ event_name: LPCWSTR,
        /* out, retval */
        receiver: *mut *mut *mut ICoreWebView2DevToolsProtocolEventReceiverVTable,
    ) -> HRESULT;

    /// Stop all navigations and pending resource fetches. Does not stop
    /// scripts.
    unsafe fn stop(&self) -> HRESULT;

    /// Add an event handler for the NewWindowRequested event.
    /// Fires when content inside the WebView requested to open a new window,
    /// such as through window.open. The app can pass a target
    /// webview that will be considered the opened window.
    ///
    /// \snippet AppWindow.cpp NewWindowRequested
    unsafe fn add_new_window_requested(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2NewWindowRequestedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_NewWindowRequested.
    unsafe fn remove_new_window_requested(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the DocumentTitleChanged event.
    /// The event fires when the DocumentTitle property of the WebView changes
    /// and may fire before or after the NavigationCompleted event.
    ///
    /// \snippet FileComponent.cpp DocumentTitleChanged
    unsafe fn add_document_title_changed(
        &self,
        /* in */
        event_handler: *mut *mut ICoreWebView2DocumentTitleChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_DocumentTitleChanged.
    unsafe fn remove_document_title_changed(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// The title for the current top level document.
    /// If the document has no explicit title or is otherwise empty,
    /// a default that may or may not match the URI of the document will be used.
    unsafe fn get_document_title(&self, /* out, retval */ title: *mut LPWSTR) -> HRESULT;

    /// Add the provided host object to script running in the WebView with the
    /// specified name.
    /// Host objects are exposed as remote object proxies via
    /// `window.chrome.webview.remoteObjects.<name>`.
    /// Remote object proxies are promises and will resolve to an object
    /// representing the host object.
    /// The promise is rejected if the app has not added an object with the name.
    /// When JavaScript code access a property or method of the object, a promise
    /// is return, which will resolve to the value returned from the host for the
    /// property or method, or rejected in case of error such as there is no such
    /// property or method on the object or parameters are invalid.
    /// For example, when the application code does the following:
    /// ```
    ///    VARIANT object;
    ///    object.vt = VT_DISPATCH;
    ///    object.pdispVal = appObject;
    ///    webview->AddRemoteObject(L"host_object", &host);
    /// ```
    /// JavaScript code in the WebView will be able to access appObject as
    /// following and then access attributes and methods of appObject:
    /// ```
    ///    let app_object = await window.chrome.webview.remoteObjects.host_object;
    ///    let attr1 = await app_object.attr1;
    ///    let result = await app_object.method1(parameters);
    /// ```
    /// Note that while simple types, IDispatch and array are supported, generic
    /// IUnknown, VT_DECIMAL, or VT_RECORD variant is not supported.
    /// Remote JavaScript objects like callback functions are represented as
    /// an VT_DISPATCH VARIANT with the object implementing IDispatch. The
    /// JavaScript callback method may be invoked using DISPID_VALUE for the
    /// DISPID.
    /// Nested arrays are supported up to a depth of 3.
    /// Arrays of by reference types are not supported.
    /// VT_EMPTY and VT_NULL are mapped into JavaScript as null. In JavaScript
    /// null and undefined are mapped to VT_EMPTY.
    ///
    /// Additionally, all remote objects are exposed as
    /// `window.chrome.webview.remoteObjects.sync.<name>`. Here the host
    /// objects are exposed as synchronous remote object proxies. These are not
    /// promises and calls to functions or property access synchronously block
    /// running script waiting to communicate cross process for the host code to
    /// run. Accordingly this can result in reliability issues and it is
    /// recommended that you use the promise based asynchronous
    /// `window.chrome.webview.remoteObjects.<name>` API described above.
    ///
    /// Synchronous remote object proxies and asynchronous remote object proxies
    /// can both proxy the same remote object. Remote changes made by one proxy
    /// will be reflected in any other proxy of that same remote object whether
    /// the other proxies and synchronous or asynchronous.
    ///
    /// While JavaScript is blocked on a synchronous call to native code, that
    /// native code is unable to call back to JavaScript. Attempts to do so will
    /// fail with HRESULT_FROM_WIN32(ERROR_POSSIBLE_DEADLOCK).
    ///
    /// Remote object proxies are JavaScript Proxy objects that intercept all
    /// property get, property set, and method invocations. Properties or methods
    /// that are a part of the Function or Object prototype are run locally.
    /// Additionally any property or method in the array
    /// `chrome.webview.remoteObjects.options.forceLocalProperties` will also be
    /// run locally. This defaults to including optional methods that have
    /// meaning in JavaScript like `toJSON` and `Symbol.toPrimitive`. You can add
    /// more to this array as required.
    ///
    /// There's a method `chrome.webview.remoteObjects.cleanupSome` that will best
    /// effort garbage collect remote object proxies.
    ///
    /// Remote object proxies additionally have the following methods which run
    /// locally:
    ///  * applyRemote, getRemote, setRemote: Perform a method invocation,
    ///    property get, or property set on the remote object. You can use these
    ///    to explicitly force a method or property to run remotely if there is
    ///    a conflicting local method or property. For instance, `proxy.toString()`
    ///    will run the local toString method on the proxy object. But
    ///    ``proxy.applyRemote('toString')`` runs `toString` on the remote proxied
    ///    object instead.
    ///  * getLocal, setLocal: Perform property get, or property set locally. You
    ///    can use these methods to force getting or setting a property on the
    ///    remote object proxy itself rather than on the remote object it
    ///    represents. For instance, `proxy.unknownProperty` will get the
    ///    property named `unknownProperty` from the remote proxied object. But
    ///    ``proxy.getLocal('unknownProperty')`` will get the value of the property
    ///    `unknownProperty` on the proxy object itself.
    ///  * sync: Asynchronous remote object proxies expose a sync method which
    ///    returns a promise for a synchronous remote object proxy for the same
    ///    remote object. For example,
    ///    `chrome.webview.remoteObjects.sample.methodCall()` returns an
    ///    asynchronous remote object proxy. You can use the `sync` method to
    ///    obtain a synchronous remote object proxy instead:
    ///    `const syncProxy = await chrome.webview.remoteObjects.sample.methodCall().sync()`
    ///  * async: Synchronous remote object proxies expose an async method which
    ///    blocks and returns an asynchronous remote object proxy for the same
    ///    remote object. For example, `chrome.webview.remoteObjects.sync.sample.methodCall()` returns a
    ///    synchronous remote object proxy. Calling the `async` method on this blocks
    ///    and then returns an asynchronous remote object proxy for the same remote object:
    ///    `const asyncProxy = chrome.webview.remoteObjects.sync.sample.methodCall().async()`
    ///  * then: Asynchronous remote object proxies have a then method. This
    ///    allows them to be awaitable. `then` will return a promise that resolves
    ///    with a representation of the remote object. If the proxy represents a
    ///    JavaScript literal then a copy of that is returned locally. If
    ///    the proxy represents a function then a non-awaitable proxy is returned.
    ///    If the proxy represents a JavaScript object with a mix of literal
    ///    properties and function properties, then the a copy of the object is
    ///    returned with some properties as remote object proxies.
    ///
    /// All other property and method invocations (other than the above Remote
    /// object proxy methods, forceLocalProperties list, and properties on
    /// Function and Object prototypes) are run remotely. Asynchronous remote
    /// object proxies return a promise representing asynchronous completion of
    /// remotely invoking the method, or getting the property.
    /// The promise resolves after the remote operations complete and
    /// the promises resolve to the resulting value of the operation.
    /// Synchronous remote object proxies work similarly but block JavaScript
    /// execution and wait for the remote operation to complete.
    ///
    /// Setting a property on an asynchronous remote object proxy works slightly
    /// differently. The set returns immediately and the return value is the value
    /// that will be set. This is a requirement of the JavaScript Proxy object.
    /// If you need to asynchronously wait for the property set to complete, use
    /// the setRemote method which returns a promise as described above.
    /// Synchronous object property set property synchronously blocks until the
    /// property is set.
    ///
    /// For example, suppose you have a COM object with the following interface
    ///
    /// \snippet RemoteObjectSample.idl AddRemoteObjectInterface
    ///
    /// We can add an instance of this interface into our JavaScript with
    /// `AddRemoteObject`. In this case we name it `sample`:
    ///
    /// \snippet ScenarioAddRemoteObject.cpp AddRemoteObject
    ///
    /// Then in the HTML document we can use this COM object via `chrome.webview.remoteObjects.sample`:
    ///
    /// \snippet ScenarioAddRemoteObject.html RemoteObjectUsage
    unsafe fn add_remote_object(
        &self,
        /* in */ name: LPCWSTR,
        /* in */ object: *mut VARIANT,
    ) -> HRESULT;

    /// Remove the host object specified by the name so that it is no longer
    /// accessible from JavaScript code in the WebView.
    /// While new access attempts will be denied, if the object is already
    /// obtained by JavaScript code in the WebView, the JavaScript code will
    /// continue to have access to that object.
    /// Calling this method for a name that is already removed or never added will
    /// fail.
    unsafe fn remove_remote_object(&self, /* in */ name: LPCWSTR) -> HRESULT;

    /// Opens the DevTools window for the current document in the WebView.
    /// Does nothing if called when the DevTools window is already open
    unsafe fn open_dev_tools_window(&self) -> HRESULT;

    /// Notifies when the ContainsFullScreenElement property changes. This means
    /// that an HTML element inside the WebView is entering fullscreen to the size
    /// of the WebView or leaving fullscreen.
    /// This event is useful when, for example, a video element requests to go
    /// fullscreen. The listener of ContainsFullScreenElementChanged can then
    /// resize the WebView in response.
    ///
    /// \snippet AppWindow.cpp ContainsFullScreenElementChanged
    unsafe fn add_contains_full_screen_element_changed(
        &self,
        /* in */
        event_handler: *mut *mut ICoreWebView2ContainsFullScreenElementChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with the corresponding add_
    /// event method.
    unsafe fn remove_contains_full_screen_element_changed(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Indicates if the WebView contains a fullscreen HTML element.
    unsafe fn get_contains_full_screen_element(
        &self,
        /* out, retval */ contains_full_screen_element: *mut BOOL,
    ) -> HRESULT;

    /// Add an event handler for the WebResourceRequested event. Fires when the
    /// WebView is performing an HTTP request to a matching URL and resource context
    /// filter that was added with AddWebResourceRequestedFilter. At least one
    /// filter must be added for the event to fire.
    ///
    /// \snippet SettingsComponent.cpp WebResourceRequested
    unsafe fn add_web_resource_requested(
        &self,
        /* in */
        event_handler: *mut *mut ICoreWebView2WebResourceRequestedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_WebResourceRequested.
    unsafe fn remove_web_resource_requested(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Adds a URI and resource context filter to the WebResourceRequested event.
    /// URI parameter can be a wildcard string ('': zero or more, '?': exactly one).
    /// nullptr is equivalent to L"".
    /// See CORE_WEBVIEW2_WEB_RESOURCE_CONTEXT enum for description of resource context filters.
    unsafe fn add_web_resource_requested_filter(
        &self,
        /* in */ uri: LPCWSTR,
        /* in */ resource_context: WebResourceContext,
    ) -> HRESULT;

    /// Removes a matching WebResource filter that was previously added for the
    /// WebResourceRequested event. If the same filter was added multiple times, then it
    /// will need to be removed as many times as it was added for the removal to be
    /// effective. Returns E_INVALIDARG for a filter that was never added.
    unsafe fn remove_web_resource_requested_filter(
        &self,
        /* in */ uri: LPCWSTR,
        /* in */ resource_context: WebResourceContext,
    ) -> HRESULT;

    /// Add an event handler for the WindowCloseRequested event.
    /// Fires when content inside the WebView requested to close the window,
    /// such as after window.close is called. The app should close the WebView
    /// and related app window if that makes sense to the app.
    ///
    /// \snippet AppWindow.cpp WindowCloseRequested
    unsafe fn add_window_close_requested(
        &self,
        /* in */
        event_handler: *mut *mut ICoreWebView2WindowCloseRequestedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_WindowCloseRequested.
    unsafe fn remove_window_close_requested(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;
}

/// Image format used by the ICoreWebView2::CapturePreview method.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum CapturePreviewImageFormat {
    /// PNG image format.
    PNG,
    /// JPEG image format.
    JPEG,
}

/// Kind of JavaScript dialog used in the ICoreWebView2ScriptDialogOpeningEventHandler
/// interface.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScriptDialogKind {
    /// A dialog invoked via the window.alert JavaScript function.
    Alert,
    /// A dialog invoked via the window.confirm JavaScript function.
    Confirm,
    /// A dialog invoked via the window.prompt JavaScript function.
    Prompt,
    /// A dialog invoked via the beforeunload JavaScript event.
    Beforeunload,
}

/// Kind of process failure used in the ICoreWebView2ProcessFailedEventHandler interface.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ProcessFailedKind {
    /// Indicates the browser process terminated unexpectedly.
    /// The WebView automatically goes into the Closed state.
    /// The app has to recreate a new WebView to recover from this failure.
    BrowserProcessExited,
    /// Indicates the render process terminated unexpectedly.
    /// A new render process will be created automatically and navigated to an
    /// error page.
    /// The app can use Reload to try to recover from this failure.
    RenderProcessExited,
    /// Indicates the render process becomes unresponsive.
    /// The app can try to navigate away from the page to recover from the
    /// failure.
    RenderProcessUnresponsive,
}

/// The type of a permission request.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PermissionKind {
    /// Unknown permission.
    UnknownPermission,
    /// Permission to capture audio.
    Microphone,
    /// Permission to capture video.
    Camera,
    /// Permission to access geolocation.
    Geolocation,
    /// Permission to send web notifications.
    /// This permission request is currently auto rejected and
    /// no event is fired for it.
    Notifications,
    /// Permission to access generic sensor.
    /// Generic Sensor covering ambient-light-sensor, accelerometer, gyroscope
    /// and magnetometer.
    OtherSensors,
    /// Permission to read system clipboard without a user gesture.
    ClipboardRead,
}

/// Response to a permission request.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PermissionState {
    /// Use default browser behavior, which normally prompt users for decision.
    Default,
    /// Grant the permission request.
    Allow,
    /// Deny the permission request.
    Deny,
}

/// Error status values for web navigations.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum WebErrorStatus {
    /// An unknown error occurred.
    Unknown,
    /// The SSL certificate common name does not match the web address.
    CertificateCommonNameIsIncorrect,
    /// The SSL certificate has expired.
    CertificateExpired,
    /// The SSL client certificate contains errors.
    ClientCertificateContainsErrors,
    /// The SSL certificate has been revoked.
    CertificateRevoked,
    /// The SSL certificate is invalid -- this could mean the certificate did not
    /// match the public key pins for the host name, the certificate is signed
    /// by an untrusted authority or using a weak sign algorithm, the
    /// certificate claimed DNS names violate name constraints, the certificate
    /// contains a weak key, the certificate's validity period is too long, lack
    /// of revocation information or revocation mechanism, non-unique host name,
    /// lack of certificate transparency information, or the certificate is
    /// chained to a [legacy Symantec
    /// root](https://security.googleblog.com/2018/03/distrust-of-symantec-pki-immediate.html).
    CertificateIsInvalid,
    /// The host is unreachable.
    ServerUnreachable,
    /// The connection has timed out.
    Timeout,
    /// The server returned an invalid or unrecognized response.
    ErrorHttpInvalidServerResponse,
    /// The connection was aborted.
    ConnectionAborted,
    /// The connection was reset.
    ConnectionReset,
    /// The Internet connection has been lost.
    Disconnected,
    /// Cannot connect to destination.
    CannotConnect,
    /// Could not resolve provided host name.
    HostNameNotResolved,
    /// The operation was canceled.
    OperationCanceled,
    /// The request redirect failed.
    RedirectFailed,
    /// An unexpected error occurred.
    UnexpectedError,
}

/// Enum for web resource request contexts.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum WebResourceContext {
    /// All resources
    All,
    /// Document resources
    Document,
    /// CSS resources
    Stylesheet,
    /// Image resources
    Image,
    /// Other media resources such as videos
    Media,
    /// Font resources
    Font,
    /// Script resources
    Script,
    /// XML HTTP requests
    XmlHttpRequest,
    /// Fetch API communication
    Fetch,
    /// TextTrack resources
    TextTrack,
    EventSource,
    Websocket,
    Manifest,
    SignedExchange,
    Ping,
    CspViolationReport,
    /// Other resources
    Other,
}

/// This interface is the owner of the CoreWebView2 object, and provides support
/// for resizing, showing and hiding, focusing, and other functionality related
/// to windowing and composition. The CoreWebView2Host owns the CoreWebView2,
/// and if all references to the CoreWebView2Host go away, the WebView will
/// be closed.
#[com_interface("6ddf7138-a19b-4e55-8994-8a198b07f492")]
pub trait ICoreWebView2Host: IUnknown {
    /// The IsVisible property determines whether to show or hide the webview.
    /// If IsVisible is set to false, the webview will be transparent and will
    /// not be rendered.  However, this will not affect the window containing
    /// the webview (the HWND parameter that was passed to CreateCoreWebView2Host).
    /// If you want that window to disappear too, call ShowWindow on it directly
    /// in addition to modifying the IsVisible property.
    /// WebView as a child window won't get window messages when the top window
    /// is minimized or restored. For performance reason, developer should set
    /// IsVisible property of the WebView to false when the app window is
    /// minimized and back to true when app window is restored. App window can do
    /// this by handling SC_MINIMIZE and SC_RESTORE command upon receiving
    /// WM_SYSCOMMAND message.
    ///
    /// \snippet ViewComponent.cpp ToggleIsVisible
    unsafe fn get_is_visible(&self, /* out, retval */ is_visible: *mut BOOL) -> HRESULT;

    /// Set the IsVisible property.
    ///
    /// \snippet ViewComponent.cpp ToggleIsVisibleOnMinimize
    unsafe fn put_is_visible(&self, /* in */ is_visible: BOOL) -> HRESULT;

    /// The webview bounds.
    /// Bounds are relative to the parent HWND. The app has two ways it can
    /// position a WebView:
    /// 1. Create a child HWND that is the WebView parent HWND. Position this
    ///    window where the WebView should be. In this case, use (0, 0) for the
    ///    WebView's Bound's top left corner (the offset).
    /// 2. Use the app's top most window as the WebView parent HWND. Set the
    ///    WebView's Bound's top left corner so that the WebView is positioned
    ///    correctly in the app.
    /// The Bound's values are in the host's coordinate space.
    unsafe fn get_bounds(&self, /* out, retval */ bounds: *mut RECT) -> HRESULT;

    /// Set the Bounds property.
    ///
    /// \snippet ViewComponent.cpp ResizeWebView
    unsafe fn put_bounds(&self, /* in */ bounds: RECT) -> HRESULT;

    /// The zoom factor for the WebView.
    /// Note that changing zoom factor could cause `window.innerWidth/innerHeight`
    /// and page layout to change.
    /// A zoom factor that is applied by the host by calling put_ZoomFactor
    /// becomes the new default zoom for the WebView. This zoom factor applies
    /// across navigations and is the zoom factor WebView is returned to when the
    /// user presses ctrl+0. When the zoom factor is changed by the user
    /// (resulting in the app receiving ZoomFactorChanged), that zoom applies
    /// only for the current page. Any user applied zoom is only for the current
    /// page and is reset on a navigation.
    /// Specifying a zoomFactor less than or equal to 0 is not allowed.
    /// WebView also has an internal supported zoom factor range. When a specified
    /// zoom factor is out of that range, it will be normalized to be within the
    /// range, and a ZoomFactorChanged event will be fired for the real
    /// applied zoom factor. When this range normalization happens, the
    /// ZoomFactor property will report the zoom factor specified during the
    /// previous modification of the ZoomFactor property until the
    /// ZoomFactorChanged event is received after webview applies the normalized
    /// zoom factor.
    unsafe fn get_zoom_factor(&self, /* out, retval */ zoom_factor: *mut f64) -> HRESULT;

    /// Set the ZoomFactor property.
    unsafe fn put_zoom_factor(&self, /* in */ zoom_factor: f64) -> HRESULT;

    /// Add an event handler for the ZoomFactorChanged event.
    /// The event fires when the ZoomFactor property of the WebView changes.
    /// The event could fire because the caller modified the ZoomFactor property,
    /// or due to the user manually modifying the zoom. When it is modified by the
    /// caller via the ZoomFactor property, the internal zoom factor is updated
    /// immediately and there will be no ZoomFactorChanged event.
    /// WebView associates the last used zoom factor for each site. Therefore, it
    /// is possible for the zoom factor to change when navigating to a different
    /// page. When the zoom factor changes due to this, the ZoomFactorChanged
    /// event fires right after the ContentLoading event.
    ///
    /// \snippet ViewComponent.cpp ZoomFactorChanged
    unsafe fn add_zoom_factor_changed(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2ZoomFactorChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_ZoomFactorChanged.
    unsafe fn remove_zoom_factor_changed(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Update Bounds and ZoomFactor properties at the same time. This operation
    /// is atomic from the host's perspecive. After returning from this function,
    /// the Bounds and ZoomFactor properties will have both been updated if the
    /// function is successful, or neither will be updated if the function fails.
    /// If Bounds and ZoomFactor are both updated by the same scale (i.e. Bounds
    /// and ZoomFactor are both doubled), then the page will not see a change in
    /// window.innerWidth/innerHeight and the WebView will render the content at
    /// the new size and zoom without intermediate renderings.
    /// This function can also be used to update just one of ZoomFactor or Bounds
    /// by passing in the new value for one and the current value for the other.
    ///
    /// \snippet ViewComponent.cpp SetBoundsAndZoomFactor
    unsafe fn set_bounds_and_zoom_factor(
        &self,
        /* in */ bounds: RECT,
        /* in */ zoom_factor: f64,
    ) -> HRESULT;

    /// Move focus into WebView. WebView will get focus and focus will be set to
    /// correspondent element in the page hosted in the WebView.
    /// For Programmatic reason, focus is set to previously focused element or
    /// the default element if there is no previously focused element.
    /// For Next reason, focus is set to the first element.
    /// For Previous reason, focus is set to the last element.
    /// WebView can also got focus through user interaction like clicking into
    /// WebView or Tab into it.
    /// For tabbing, the app can call MoveFocus with Next or Previous to align
    /// with tab and shift+tab respectively when it decides the WebView is the
    /// next tabbable element. Or, the app can call IsDialogMessage as part of
    /// its message loop to allow the platform to auto handle tabbing. The
    /// platform will rotate through all windows with WS_TABSTOP. When the
    /// WebView gets focus from IsDialogMessage, it will internally put the focus
    /// on the first or last element for tab and shift+tab respectively.
    ///
    /// \snippet App.cpp MoveFocus0
    ///
    /// \snippet ControlComponent.cpp MoveFocus1
    ///
    /// \snippet ControlComponent.cpp MoveFocus2
    unsafe fn move_focus(&self, /* in */ reason: MoveFocusReason) -> HRESULT;

    /// Add an event handler for the MoveFocusRequested event.
    /// MoveFocusRequested fires when user tries to tab out of the WebView.
    /// The WebView's focus has not changed when this event is fired.
    ///
    /// \snippet ControlComponent.cpp MoveFocusRequested
    unsafe fn add_move_focus_requested(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2MoveFocusRequestedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_MoveFocusRequested.
    unsafe fn remove_move_focus_requested(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// Add an event handler for the GotFocus event.
    /// GotFocus fires when WebView got focus.
    unsafe fn add_got_focus(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2FocusChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_GotFocus.
    unsafe fn remove_got_focus(&self, /* in */ token: EventRegistrationToken) -> HRESULT;

    /// Add an event handler for the LostFocus event.
    /// LostFocus fires when WebView lost focus.
    /// In the case where MoveFocusRequested event is fired, the focus is still
    /// on WebView when MoveFocusRequested event fires. Lost focus only fires
    /// afterwards when app's code or default action of MoveFocusRequested event
    /// set focus away from WebView.
    unsafe fn add_lost_focus(
        &self,
        /* in */ event_handler: *mut *mut ICoreWebView2FocusChangedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_LostFocus.
    unsafe fn remove_lost_focus(&self, /* in */ token: EventRegistrationToken) -> HRESULT;

    /// Add an event handler for the AcceleratorKeyPressed event.
    /// AcceleratorKeyPressed fires when an accelerator key or key combo is
    /// pressed or released while the WebView is focused. A key is considered an
    /// accelerator if either:
    ///   1. Ctrl or Alt is currently being held, or
    ///   2. the pressed key does not map to a character.
    /// A few specific keys are never considered accelerators, such as Shift.
    /// The Escape key is always considered an accelerator.
    ///
    /// Autorepeated key events caused by holding the key down will also fire this
    /// event.  You can filter these out by checking the event args'
    /// KeyEventLParam or PhysicalKeyStatus.
    ///
    /// In windowed mode, this event handler is called synchronously. Until you
    /// call Handle() on the event args or the event handler returns, the browser
    /// process will be blocked and outgoing cross-process COM calls will fail
    /// with RPC_E_CANTCALLOUT_ININPUTSYNCCALL. All CoreWebView2 API methods will
    /// work, however.
    ///
    /// In windowless mode, the event handler is called asynchronously.  Further
    /// input will not reach the browser until the event handler returns or
    /// Handle() is called, but the browser process itself will not be blocked,
    /// and outgoing COM calls will work normally.
    ///
    /// It is recommended to call Handle(TRUE) as early as you can know that you want
    /// to handle the accelerator key.
    ///
    /// \snippet ControlComponent.cpp AcceleratorKeyPressed
    unsafe fn add_accelerator_key_pressed(
        &self,
        /* in */
        event_handler: *mut *mut ICoreWebView2AcceleratorKeyPressedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_AcceleratorKeyPressed.
    unsafe fn remove_accelerator_key_pressed(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;

    /// The parent window provided by the app that this WebView is using to
    /// render content. This API initially returns the window passed into
    /// CreateCoreWebView2Host.
    unsafe fn get_parent_window(
        &self,
        /* out, retval */ top_level_window: *mut HWND,
    ) -> HRESULT;

    /// Set the parent window for the WebView. This will cause the WebView to
    /// reparent its window to the newly provided window.
    unsafe fn put_parent_window(&self, /* in */ top_level_window: HWND) -> HRESULT;

    /// This is a notification separate from put_Bounds that tells WebView its
    /// parent (or any ancestor) HWND moved. This is needed for accessibility and
    /// certain dialogs in WebView to work correctly.
    /// \snippet AppWindow.cpp NotifyParentWindowPositionChanged
    unsafe fn notify_parent_window_position_changed(&self) -> HRESULT;

    /// Closes the WebView and cleans up the underlying browser instance.
    /// Cleaning up the browser instace will release the resources powering the WebView.
    /// The browser instance will be shut down if there are no other WebViews using it.
    ///
    /// After calling Close, all method calls will fail and event handlers
    /// will stop firing. Specifically, the WebView will release its references
    /// to its event handlers when Close is called.
    ///
    /// Close is implicitly called when the CoreWebView2Host loses its final
    /// reference and is destructed. But it is best practice to explicitly call
    /// Close to avoid any accidental cycle of references between the WebView
    /// and the app code. Specifically, if you capture a reference to the WebView
    /// in an event handler you will create a reference cycle between the WebView
    /// and the event handler. Calling Close will break this cycle by releasing
    /// all event handlers. But to avoid this situation it is best practice both
    /// to explicitly call Close on the WebView and to not capture a reference to
    /// the WebView to ensure the WebView can be cleaned up correctly.
    ///
    /// \snippet AppWindow.cpp Close
    unsafe fn close(&self) -> HRESULT;

    /// Gets the CoreWebView2 associated with this CoreWebView2Host.
    unsafe fn get_core_web_view2(
        &self,
        /* out, retval */ core_web_view2: *mut *mut *mut ICoreWebView2VTable,
    ) -> HRESULT;
}

/// Reason for moving focus.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum MoveFocusReason {
    /// Code setting focus into WebView.
    Programmatic,
    /// Moving focus due to Tab traversal forward.
    Next,
    /// Moving focus due to Tab traversal backward.
    Previous,
}

/// The type of key event that triggered an AcceleratorKeyPressed event.
#[repr(u32)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum KeyEventKind {
    /// Correspond to window message WM_KEYDOWN.
    KeyDown,
    /// Correspond to window message WM_KEYUP.
    KeyUp,
    /// Correspond to window message WM_SYSKEYDOWN.
    SystemKeyDown,
    /// Correspond to window message WM_SYSKEYUP.
    SystemKeyUp,
}

/// A structure representing the information packed into the LPARAM given
/// to a Win32 key event.  See the documentation for WM_KEYDOWN for details
/// at https://docs.microsoft.com/windows/win32/inputdev/wm-keydown
#[repr(C)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct PhysicalKeyStatus {
    /// The repeat count for the current message.
    pub repeat_count: UINT32,
    /// The scan code.
    pub scan_code: UINT32,
    /// Indicates whether the key is an extended key.
    pub is_extended_key: BOOL,
    /// The context code.
    pub is_menu_key_down: BOOL,
    /// The previous key state.
    pub was_key_down: BOOL,
    /// The transition state.
    pub is_key_released: BOOL,
}

/// This interface is used to complete deferrals on event args that
/// support getting deferrals via their GetDeferral method.
#[com_interface("C1000D7C-4817-40EB-A2AE-3B929D5A8EE3")]
pub trait ICoreWebView2Deferral: IUnknown {
    /// Completes the associated deferred event. Complete should only be
    /// called once for each deferral taken.
    unsafe fn complete(&self) -> HRESULT;
}

/// Defines properties that enable, disable, or modify WebView
/// features. Setting changes made after NavigationStarting event will not
/// apply until the next top level navigation.
#[com_interface("D58A964A-13C4-44FB-81AD-64AE242E9ADC")]
pub trait ICoreWebView2Settings: IUnknown {
    /// Controls if JavaScript execution is enabled in all future
    /// navigations in the WebView.  This only affects scripts in the document;
    /// scripts injected with ExecuteScript will run even if script is disabled.
    /// It is true by default.
    ///
    /// \snippet SettingsComponent.cpp IsScriptEnabled
    unsafe fn get_is_script_enabled(
        &self,
        /* out, retval */ is_script_enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the IsScriptEnabled property.
    unsafe fn put_is_script_enabled(&self, /* in */ is_script_enabled: BOOL) -> HRESULT;

    /// The IsWebMessageEnabled property is used when loading a new
    /// HTML document. If set to true, communication from the host to the
    /// webview's top level HTML document is allowed via PostWebMessageAsJson,
    /// PostWebMessageAsString, and window.chrome.webview's message event
    /// (see PostWebMessageAsJson documentation for details).
    /// Communication from the webview's top level HTML document
    /// to the host is allowed via window.chrome.webview's postMessage function
    /// and the SetWebMessageReceivedEventHandler method (see the
    /// SetWebMessageReceivedEventHandler documentation for details).
    /// If set to false, then communication is disallowed.
    /// PostWebMessageAsJson and PostWebMessageAsString will
    /// fail with E_ACCESSDENIED and window.chrome.webview.postMessage will fail
    /// by throwing an instance of an Error object.
    /// It is true by default.
    ///
    /// \snippet ScenarioWebMessage.cpp IsWebMessageEnabled
    unsafe fn get_is_web_message_enabled(
        &self,
        /* out, retval */ is_web_message_enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the IsWebMessageEnabled property.
    unsafe fn put_is_web_message_enabled(
        &self,
        /* in */ is_web_message_enabled: BOOL,
    ) -> HRESULT;

    /// AreDefaultScriptDialogsEnabled is used when loading a new
    /// HTML document. If set to false, then WebView won't render the default
    /// javascript dialog box (Specifically those shown by the javascript alert,
    /// confirm, prompt functions and beforeunload event). Instead, if an event
    /// handler is set by SetScriptDialogOpeningEventHandler, WebView will send an
    /// event that will contain all of the information for the dialog and allow
    /// the host app to show its own custom UI.
    unsafe fn get_are_default_script_dialogs_enabled(
        &self,
        /* out, retval */ are_default_script_dialogs_enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the AreDefaultScriptDialogsEnabled property.
    unsafe fn put_are_default_script_dialogs_enabled(
        &self,
        /* in */ are_default_script_dialogs_enabled: BOOL,
    ) -> HRESULT;

    /// IsStatusBarEnabled controls whether the status bar will be displayed. The
    /// status bar is usually displayed in the lower left of the WebView and shows
    /// things such as the URI of a link when the user hovers over it and other
    /// information. It is true by default.
    unsafe fn get_is_status_bar_enabled(
        &self,
        /* out, retval */ is_status_bar_enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the IsStatusBarEnabled property.
    unsafe fn put_is_status_bar_enabled(
        &self,
        /* in */ is_status_bar_enabled: BOOL,
    ) -> HRESULT;

    /// AreDevToolsEnabled controls whether the user is able to use the context
    /// menu or keyboard shortcuts to open the DevTools window.
    /// It is true by default.
    unsafe fn get_are_dev_tools_enabled(
        &self,
        /* out, retval */ are_dev_tools_enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the AreDevToolsEnabled property.
    unsafe fn put_are_dev_tools_enabled(
        &self,
        /* in */ are_dev_tools_enabled: BOOL,
    ) -> HRESULT;

    /// The AreDefaultContextMenusEnabled property is used to prevent
    /// default context menus from being shown to user in webview. Defaults to TRUE.
    ///
    /// \snippet SettingsComponent.cpp DisableContextMenu
    unsafe fn get_are_default_context_menus_enabled(
        &self,
        /* out, retval */ enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the AreDefaultContextMenusEnabled property
    unsafe fn put_are_default_context_menus_enabled(&self, /* in */ enabled: BOOL) -> HRESULT;

    /// The AreRemoteObjectsAllowed property is used to control whether
    /// remote objects are accessible from the page in webview. Defaults to TRUE.
    ///
    /// \snippet SettingsComponent.cpp RemoteObjectsAccess
    unsafe fn get_are_remote_objects_allowed(
        &self,
        /* out, retval */ allowed: *mut BOOL,
    ) -> HRESULT;

    /// Set the AreRemoteObjectsAllowed property
    unsafe fn put_are_remote_objects_allowed(&self, /* in */ allowed: BOOL) -> HRESULT;

    /// The IsZoomControlEnabled property is used to prevent the user from
    /// impacting the zoom of the WebView. Defaults to TRUE.
    /// When disabled, user will not be able to zoom using ctrl+/- or
    /// ctrl+mouse wheel, but the zoom can be set via put_ZoomFactor API.
    ///
    /// \snippet SettingsComponent.cpp DisableZoomControl
    unsafe fn get_is_zoom_control_enabled(
        &self,
        /* out, retval */ enabled: *mut BOOL,
    ) -> HRESULT;

    /// Set the IsZoomControlEnabled property
    unsafe fn put_is_zoom_control_enabled(&self, /* in */ enabled: BOOL) -> HRESULT;
}

/// Event args for the ProcessFailed event.
#[com_interface("9E354785-CFA2-480A-84E0-57837ADD8E36")]
pub trait ICoreWebView2ProcessFailedEventArgs: IUnknown {
    /// The kind of process failure that has occurred.
    unsafe fn get_process_failed_kind(
        &self,
        /* out, retval */ process_failed_kind: *mut ProcessFailedKind,
    ) -> HRESULT;
}

/// The caller implements this interface to receive ProcessFailed events.
#[com_interface("A85C66A9-DE47-47F7-AD64-ABB32F1CF14D")]
pub trait ICoreWebView2ProcessFailedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2ProcessFailedEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive ZoomFactorChanged
/// events. Use the ICoreWebView2Host.ZoomFactor property to get the
/// modified zoom factor.
#[com_interface("1B03A40F-92B7-443A-87E0-B65714B6CB9D")]
pub trait ICoreWebView2ZoomFactorChangedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event. There are no event args and the args
    /// parameter will be null.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2HostVTable,
        /* in */ args: *mut *mut IUnknownVTable,
    ) -> HRESULT;
}

/// Iterator for a collection of HTTP headers. See ICoreWebView2HttpRequestHeaders
/// and ICoreWebView2HttpResponseHeaders.
/// \snippet ScenarioWebViewEventMonitor.cpp HttpRequestHeaderIterator
#[com_interface("B0F8A736-CC49-4414-BB9C-FDBC02599622")]
pub trait ICoreWebView2HttpHeadersCollectionIterator: IUnknown {
    /// Get the name and value of the current HTTP header of the iterator. This
    /// method will fail if the last call to MoveNext set has_next to FALSE.
    unsafe fn get_current_header(
        &self,
        /* out */ name: *mut LPWSTR,
        /* out */ value: *mut LPWSTR,
    ) -> HRESULT;

    /// True when the iterator hasn't run out of headers. If the collection over
    /// which the iterator is iterating is empty or if the iterator has gone past
    /// the end of the collection then this is false.
    unsafe fn get_has_current_header(
        &self,
        /* out, retval */ has_current: *mut BOOL,
    ) -> HRESULT;

    /// Move the iterator to the next HTTP header in the collection. The hasNext
    /// parameter will be set to FALSE if there are no more HTTP headers. After
    /// this occurs the GetCurrentHeader method will fail if called.
    unsafe fn move_next(&self, /* out */ has_next: *mut BOOL) -> HRESULT;
}

/// HTTP request headers. Used to inspect the HTTP request on
/// WebResourceRequested event and NavigationStarting event.
/// Note, you can modify the HTTP request headers from a WebResourceRequested event,
/// but not from a NavigationStarting event.
#[com_interface("160B895B-D0AF-4A42-A14F-5571CFA68B03")]
pub trait ICoreWebView2HttpRequestHeaders: IUnknown {
    /// Gets the header value matching the name.
    unsafe fn get_header(
        &self,
        /* in */ name: LPCWSTR,
        /* out, retval */ value: *mut LPWSTR,
    ) -> HRESULT;

    /// Gets the header value matching the name via an iterator.
    unsafe fn get_headers(
        &self,
        /* in */ name: LPCWSTR,
        /* out, retval */
        iterator: *mut *mut *mut ICoreWebView2HttpHeadersCollectionIteratorVTable,
    ) -> HRESULT;

    /// Checks whether the headers contain an entry matching the header name.
    unsafe fn contains(
        &self,
        /* in */ name: LPCWSTR,
        /* out, retval */ contains: *mut BOOL,
    ) -> HRESULT;

    /// Adds or updates header that matches the name.
    unsafe fn set_header(
        &self,
        /* in */ name: LPCWSTR,
        /* in */ value: LPCWSTR,
    ) -> HRESULT;

    /// Removes header that matches the name.
    unsafe fn remove_header(&self, /* in */ name: LPCWSTR) -> HRESULT;

    /// Gets an iterator over the collection of request headers.
    unsafe fn get_iterator(
        &self,
        /* out, retval */
        iterator: *mut *mut *mut ICoreWebView2HttpHeadersCollectionIteratorVTable,
    ) -> HRESULT;
}

/// HTTP response headers. Used to construct a WebResourceResponse for the
/// WebResourceRequested event.
#[com_interface("3E81928E-DDAE-4B3C-BCEF-DB2752BCFA1E")]
pub trait ICoreWebView2HttpResponseHeaders: IUnknown {
    /// Appends header line with name and value.
    unsafe fn append_header(
        &self,
        /* in */ name: LPCWSTR,
        /* in */ value: LPCWSTR,
    ) -> HRESULT;

    /// Checks whether the headers contain entries matching the header name.
    unsafe fn contains(
        &self,
        /* in */ name: LPCWSTR,
        /* out, retval */ contains: *mut BOOL,
    ) -> HRESULT;

    /// Gets the first header value in the collection matching the name.
    unsafe fn get_header(
        &self,
        /* in */ name: LPCWSTR,
        /* out, retval */ value: *mut LPWSTR,
    ) -> HRESULT;

    /// Gets the header values matching the name.
    unsafe fn get_headers(
        &self,
        /* in */ name: LPCWSTR,
        /* out, retval */
        iterator: *mut *mut *mut ICoreWebView2HttpHeadersCollectionIteratorVTable,
    ) -> HRESULT;

    /// Gets an iterator over the collection of entire response headers.
    unsafe fn get_iterator(
        &self,
        /* out, retval */
        iterator: *mut *mut *mut ICoreWebView2HttpHeadersCollectionIteratorVTable,
    ) -> HRESULT;
}

/// An HTTP request used with the WebResourceRequested event.
#[com_interface("7471A125-D5E8-45A8-B119-F9E9230D4D0B")]
pub trait ICoreWebView2WebResourceRequest: IUnknown {
    /// The request URI.
    unsafe fn get_uri(&self, /* out, retval */ uri: *mut LPWSTR) -> HRESULT;

    /// Set the Uri property.
    unsafe fn put_uri(&self, /* in */ uri: LPCWSTR) -> HRESULT;

    /// The HTTP request method.
    unsafe fn get_method(&self, /* out, retval */ method: *mut LPWSTR) -> HRESULT;

    /// Set the Method property.
    unsafe fn put_method(&self, /* in */ method: LPCWSTR) -> HRESULT;

    /// The HTTP request message body as stream. POST data would be here.
    /// If a stream is set, which will override the message body, the stream must
    /// have all the content data available by the time this
    /// response's WebResourceRequested event deferral is completed. Stream
    /// should be agile or be created from a background STA to prevent performance
    /// impact to the UI thread. Null means no content data. IStream semantics
    /// apply (return S_OK to Read calls until all data is exhausted)
    unsafe fn get_content(
        &self,
        /* out, retval */ content: *mut *mut *mut IStreamVTable,
    ) -> HRESULT;

    /// Set the Content property.
    unsafe fn put_content(&self, /* in */ content: *mut *mut IStreamVTable) -> HRESULT;

    /// The mutable HTTP request headers
    unsafe fn get_headers(
        &self,
        /* out, retval */ headers: *mut *mut *mut ICoreWebView2HttpRequestHeadersVTable,
    ) -> HRESULT;
}

/// An HTTP response used with the WebResourceRequested event.
#[com_interface("2B842125-E3B4-40A2-8BB8-C31AABF70E0A")]
pub trait ICoreWebView2WebResourceResponse: IUnknown {
    /// HTTP response content as stream. Stream must have all the
    /// content data available by the time this response's WebResourceRequested
    /// event deferral is completed. Stream should be agile or be created from
    /// a background thread to prevent performance impact to the UI thread.
    /// Null means no content data. IStream semantics
    /// apply (return S_OK to Read calls until all data is exhausted)
    unsafe fn get_content(
        &self,
        /* out, retval */ content: *mut *mut *mut IStreamVTable,
    ) -> HRESULT;

    /// Set the Content property.
    unsafe fn put_content(&self, /* in */ content: *mut *mut IStreamVTable) -> HRESULT;

    /// Overridden HTTP response headers.
    unsafe fn get_headers(
        &self,
        /* out, retval */ headers: *mut *mut *mut ICoreWebView2HttpResponseHeadersVTable,
    ) -> HRESULT;

    /// The HTTP response status code.
    unsafe fn get_status_code(&self, /* out, retval */ status_code: *mut i32) -> HRESULT;

    /// Set the StatusCode property.
    unsafe fn put_status_code(&self, /* in */ status_code: i32) -> HRESULT;

    /// The HTTP response reason phrase
    unsafe fn get_reason_phrase(
        &self,
        /* out, retval */ reason_phrase: *mut LPWSTR,
    ) -> HRESULT;

    /// Set the ReasonPhrase property.
    unsafe fn put_reason_phrase(&self, /* in */ reason_phrase: LPCWSTR) -> HRESULT;
}

/// Event args for the NavigationStarting event.
#[com_interface("1C81A448-575B-44A1-9ABD-1B93A3DE9E03")]
pub trait ICoreWebView2NavigationStartingEventArgs: IUnknown {
    /// The uri of the requested navigation.
    unsafe fn get_uri(&self, /* out, retval */ uri: *mut LPWSTR) -> HRESULT;

    /// True when the navigation was initiated through a user gesture as opposed
    /// to programmatic navigation.
    unsafe fn get_is_user_initiated(
        &self,
        /* out, retval */ is_user_initiated: *mut BOOL,
    ) -> HRESULT;

    /// True when the navigation is redirected.
    unsafe fn get_is_redirected(&self, /* out, retval */ is_redirected: *mut BOOL) -> HRESULT;

    /// The HTTP request headers for the navigation.
    /// Note, you cannot modify the HTTP request headers in a NavigationStarting event.
    unsafe fn get_request_headers(
        &self,
        /* out, retval */
        request_headers: *mut *mut *mut ICoreWebView2HttpRequestHeadersVTable,
    ) -> HRESULT;

    /// The host may set this flag to cancel the navigation.
    /// If set, it will be as if the navigation never happened and the current
    /// page's content will be intact. For performance reasons, GET HTTP requests
    /// may happen, while the host is responding. This means cookies can be set
    /// and used part of a request for the navigation.
    unsafe fn get_cancel(&self, /* out, retval */ cancel: *mut BOOL) -> HRESULT;

    /// Set the Cancel property.
    unsafe fn put_cancel(&self, /* in */ cancel: BOOL) -> HRESULT;

    /// The ID of the navigation.
    unsafe fn get_navigation_id(
        &self,
        /* out, retval */ navigation_id: *mut UINT64,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the NavigationStarting
/// event.
#[com_interface("CD2F4CAE-BA09-47F3-94EE-A785CEC7C907")]
pub trait ICoreWebView2NavigationStartingEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2NavigationStartingEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the ContentLoading event.
#[com_interface("696ED8C1-4657-4769-928F-10EF8040ED25")]
pub trait ICoreWebView2ContentLoadingEventArgs: IUnknown {
    /// True if the loaded content is an error page.
    unsafe fn get_is_error_page(&self, /* out, retval */ is_error_page: *mut BOOL) -> HRESULT;

    /// The ID of the navigation.
    unsafe fn get_navigation_id(
        &self,
        /* out, retval */ navigation_id: *mut UINT64,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the ContentLoading event.
#[com_interface("70057D5C-0BAA-4219-97B0-FFF1C088ED32")]
pub trait ICoreWebView2ContentLoadingEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ webview: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2ContentLoadingEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the SourceChanged event.
#[com_interface("26D4B817-9496-4F67-AEAB-24EB38482037")]
pub trait ICoreWebView2SourceChangedEventArgs: IUnknown {
    /// True if the page being navigated to is a new document.
    unsafe fn get_is_new_document(
        &self,
        /* out, retval */ is_new_document: *mut BOOL,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the SourceChanged event.
#[com_interface("E345159A-B573-41AB-A4F7-F94CB238AF45")]
pub trait ICoreWebView2SourceChangedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ webview: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2SourceChangedEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the HistoryChanged event.
#[com_interface("29211B19-F775-48CC-9757-5DA3CA1F626A")]
pub trait ICoreWebView2HistoryChangedEventHandler: IUnknown {
    /// There are no event args and the args parameter will be null.
    unsafe fn invoke(
        &self,
        /* in */ webview: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut IUnknownVTable,
    ) -> HRESULT;
}

/// Event args for the ScriptDialogOpening event.
#[com_interface("49C08E35-FCE1-4C6A-8DBD-6F58666C0CBE")]
pub trait ICoreWebView2ScriptDialogOpeningEventArgs: IUnknown {
    /// The URI of the page that requested the dialog box.
    unsafe fn get_uri(&self, /* out, retval */ uri: *mut LPWSTR) -> HRESULT;

    /// The kind of JavaScript dialog box. Accept, confirm, prompt, or
    /// beforeunload.
    unsafe fn get_kind(&self, /* out, retval */ kind: *mut ScriptDialogKind) -> HRESULT;

    /// The message of the dialog box. From JavaScript this is the first parameter
    /// passed to alert, confirm, and prompt and is empty for beforeunload.
    unsafe fn get_message(&self, /* out, retval */ message: *mut LPWSTR) -> HRESULT;

    /// The host may call this to respond with OK to confirm, prompt, and
    /// beforeunload dialogs or not call this method to indicate cancel. From
    /// JavaScript, this means that the confirm and beforeunload function returns
    /// true if Accept is called. And for the prompt function it returns the value
    /// of ResultText if Accept is called and returns false otherwise.
    unsafe fn accept(&self) -> HRESULT;

    /// The second parameter passed to the JavaScript prompt dialog. This is the
    /// the default value to use for the result of the prompt JavaScript function.
    unsafe fn get_default_text(&self, /* out, retval */ default_text: *mut LPWSTR) -> HRESULT;

    /// The return value from the JavaScript prompt function if Accept is called.
    /// This is ignored for dialog kinds other than prompt. If Accept is not
    /// called this value is ignored and false is returned from prompt.
    unsafe fn get_result_text(&self, /* out, retval */ result_text: *mut LPWSTR) -> HRESULT;

    /// Set the ResultText property.
    unsafe fn put_result_text(&self, /* in */ result_text: LPCWSTR) -> HRESULT;

    /// GetDeferral can be called to return an ICoreWebView2Deferral object.
    /// You can use this to complete the event at a later time.
    unsafe fn get_deferral(
        &self,
        /* out, retval */ deferral: *mut *mut *mut ICoreWebView2DeferralVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the ScriptDialogOpening
/// event.
#[com_interface("E4CDFD7A-AA15-4738-8A8F-4C8C28A9BAC1")]
pub trait ICoreWebView2ScriptDialogOpeningEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2ScriptDialogOpeningEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the NavigationCompleted event.
#[com_interface("1337EED4-BC5B-48FB-9672-80D18733CFD5")]
pub trait ICoreWebView2NavigationCompletedEventArgs: IUnknown {
    /// True when the navigation is successful. This
    /// is false for a navigation that ended up in an error page (failures due to
    /// no network, DNS lookup failure, HTTP server responds with 4xx), but could
    /// also be false for additional things such as window.stop() called on
    /// navigated page.
    unsafe fn get_is_success(&self, /* out, retval */ is_success: *mut BOOL) -> HRESULT;

    /// The error code if the navigation failed.
    unsafe fn get_web_error_status(
        &self,
        /* out, retval */ core_webview2_web_error_status: *mut WebErrorStatus,
    ) -> HRESULT;

    /// The ID of the navigation.
    unsafe fn get_navigation_id(
        &self,
        /* out, retval */ navigation_id: *mut UINT64,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the NavigationCompleted
/// event.
#[com_interface("17EB2F75-B65B-4E5F-A0E1-933126DDD5BB")]
pub trait ICoreWebView2NavigationCompletedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2NavigationCompletedEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the PermissionRequested event.
#[com_interface("DBB6C9C9-FBB5-40FD-8843-5BE65807FD8A")]
pub trait ICoreWebView2PermissionRequestedEventArgs: IUnknown {
    /// The origin of the web content that requests the permission.
    unsafe fn get_uri(&self, /* out, retval */ uri: *mut LPWSTR) -> HRESULT;

    /// The type of the permission that is requested.
    unsafe fn get_permission_kind(
        &self,
        /* out, retval */ value: *mut PermissionKind,
    ) -> HRESULT;

    /// True when the permission request was initiated through a user gesture.
    /// Note that being initiated through a user gesture doesn't mean that user
    /// intended to access the associated resource.
    unsafe fn get_is_user_initiated(
        &self,
        /* out, retval */ is_user_initiated: *mut BOOL,
    ) -> HRESULT;

    /// The status of a permission request, i.e. whether the request is granted.
    /// Default value is CORE_WEBVIEW2_PERMISSION_STATE_DEFAULT.
    unsafe fn get_state(&self, /* out, retval */ value: *mut PermissionState) -> HRESULT;

    /// Set the State property.
    unsafe fn put_state(&self, /* in */ value: PermissionState) -> HRESULT;

    /// GetDeferral can be called to return an ICoreWebView2Deferral object.
    /// Developer can use the deferral object to make the permission decision
    /// at a later time.
    unsafe fn get_deferral(
        &self,
        /* out, retval */ deferral: *mut *mut *mut ICoreWebView2DeferralVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the PermissionRequested
/// event.
#[com_interface("7079A1F0-CF14-4046-8E26-46BF54163673")]
pub trait ICoreWebView2PermissionRequestedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2PermissionRequestedEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the result of the
/// AddScriptToExecuteOnDocumentCreated method.
#[com_interface("8889C588-9DC7-4266-9BB3-369AFDDE2A7F")]
pub trait ICoreWebView2AddScriptToExecuteOnDocumentCreatedCompletedHandler: IUnknown {
    /// Called to provide the implementer with the completion status and result
    /// of the corresponding asynchronous method call.
    unsafe fn invoke(
        &self,
        /* in */ error_code: HRESULT,
        /* in */ id: LPCWSTR,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the result of the
/// ExecuteScript method.
#[com_interface("51457AE2-93FD-404E-A957-3D6034EAD733")]
pub trait ICoreWebView2ExecuteScriptCompletedHandler: IUnknown {
    /// Called to provide the implementer with the completion status and result
    /// of the corresponding asynchronous method call.
    unsafe fn invoke(
        &self,
        /* in */ error_code: HRESULT,
        /* in */ result_object_as_json: LPCWSTR,
    ) -> HRESULT;
}

/// Event args for the WebResourceRequested event.
#[com_interface("6EF9912F-5A9D-42A9-8C17-9BB53E1D5C63")]
pub trait ICoreWebView2WebResourceRequestedEventArgs: IUnknown {
    /// The HTTP request.
    unsafe fn get_request(
        &self,
        /* out, retval */ request: *mut *mut *mut ICoreWebView2WebResourceRequestVTable,
    ) -> HRESULT;

    /// The HTTP response.
    unsafe fn get_response(
        &self,
        /* out, retval */ response: *mut *mut *mut ICoreWebView2WebResourceResponseVTable,
    ) -> HRESULT;

    /// Set the Response property.
    unsafe fn put_response(
        &self,
        /* in */ response: *mut *mut ICoreWebView2WebResourceResponseVTable,
    ) -> HRESULT;

    /// Obtain an ICoreWebView2Deferral object and put the event into a deferred state.
    /// You can use the ICoreWebView2Deferral object to complete the network request at a
    /// later time.
    unsafe fn get_deferral(
        &self,
        /* out, retval */ deferral: *mut *mut *mut ICoreWebView2DeferralVTable,
    ) -> HRESULT;

    /// The web resource request contexts.
    unsafe fn get_resource_context(
        &self,
        /* out, retval */ context: *mut WebResourceContext,
    ) -> HRESULT;
}

/// Fires when an HTTP request is made in the webview. The host can override
/// request, response headers and response content.
#[com_interface("A8DC0663-3C2C-4190-8129-5F1F598CA7B8")]
pub trait ICoreWebView2WebResourceRequestedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2WebResourceRequestedEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this method to receive the result of the
/// CapturePreview method. The result is written to the stream provided in
/// the CapturePreview method call.
#[com_interface("A1A2EC1C-B5C3-4EB2-9BCB-9166AFAA0E85")]
pub trait ICoreWebView2CapturePreviewCompletedHandler: IUnknown {
    /// Called to provide the implementer with the completion status
    /// of the corresponding asynchronous method call.
    unsafe fn invoke(&self, /* in */ result: HRESULT) -> HRESULT;
}

/// The caller implements this method to receive the GotFocus and LostFocus
/// events. There are no event args for this event.
#[com_interface("19F31771-9BB5-422B-9A0A-6EDDAF4FFE0F")]
pub trait ICoreWebView2FocusChangedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event. There are no event args and the args
    /// parameter will be null.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2HostVTable,
        /* in */ args: *mut *mut IUnknownVTable,
    ) -> HRESULT;
}

/// Event args for the MoveFocusRequested event.
#[com_interface("CE31A597-E202-49B9-A9BE-825481ED517E")]
pub trait ICoreWebView2MoveFocusRequestedEventArgs: IUnknown {
    /// The reason for WebView to fire the MoveFocus Requested event.
    unsafe fn get_reason(&self, /* out, retval */ value: *mut MoveFocusReason) -> HRESULT;

    /// Indicate whether the event has been handled by the app.
    /// If the app has moved the focus to its desired location, it should set
    /// Handled property to TRUE.
    /// When Handled property is false after the event handler returns, default
    /// action will be taken. The default action is to try to find the next tab
    /// stop child window in the app and try to move focus to that window. If
    /// there is no other such window to move focus to, focus will be cycled
    /// within the WebView's web content.
    unsafe fn get_handled(&self, /* out, retval */ value: *mut BOOL) -> HRESULT;

    /// Set the Handled property.
    unsafe fn put_handled(&self, /* in */ value: BOOL) -> HRESULT;
}

/// The caller implements this method to receive the MoveFocusRequested event.
#[com_interface("01BA7131-3DBE-4C83-A789-99C467A2C3F5")]
pub trait ICoreWebView2MoveFocusRequestedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2HostVTable,
        /* in */ args: *mut *mut ICoreWebView2MoveFocusRequestedEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the WebMessageReceived event.
#[com_interface("B21D70E2-942E-44EB-B843-22C156FDE288")]
pub trait ICoreWebView2WebMessageReceivedEventArgs: IUnknown {
    /// The URI of the document that sent this web message.
    unsafe fn get_source(&self, /* out, retval */ source: *mut LPWSTR) -> HRESULT;

    /// The message posted from the webview content to the host converted to a
    /// JSON string. Use this to communicate via JavaScript objects.
    ///
    /// For example the following postMessage calls result in the
    /// following WebMessageAsJson values:
    ///
    /// ```
    ///    postMessage({'a': 'b'})      L"{\"a\": \"b\"}"
    ///    postMessage(1.2)             L"1.2"
    ///    postMessage('example')       L"\"example\""
    /// ```
    unsafe fn get_web_message_as_json(
        &self,
        /* out, retval */ web_message_as_json: *mut LPWSTR,
    ) -> HRESULT;

    /// If the message posted from the webview content to the host is a
    /// string type, this method will return the value of that string. If the
    /// message posted is some other kind of JavaScript type this method will fail
    /// with E_INVALIDARG. Use this to communicate via simple strings.
    ///
    /// For example the following postMessage calls result in the
    /// following WebMessageAsString values:
    ///
    /// ```
    ///    postMessage({'a': 'b'})      E_INVALIDARG
    ///    postMessage(1.2)             E_INVALIDARG
    ///    postMessage('example')       L"example"
    /// ```
    unsafe fn try_get_web_message_as_string(
        &self,
        /* out, retval */ web_message_as_string: *mut LPWSTR,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the WebMessageReceived
/// event.
#[com_interface("ABABDC66-DF8D-487D-A737-7B25E8F835AA")]
pub trait ICoreWebView2WebMessageReceivedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2WebMessageReceivedEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the DevToolsProtocolEventReceived event.
#[com_interface("7EF09904-8B46-4FE1-87FF-5A28EFAF7723")]
pub trait ICoreWebView2DevToolsProtocolEventReceivedEventArgs: IUnknown {
    /// The parameter object of the corresponding DevToolsProtocol event
    /// represented as a JSON string.
    unsafe fn get_parameter_object_as_json(
        &self,
        /* out, retval */ parameter_object_as_json: *mut LPWSTR,
    ) -> HRESULT;
}

/// The caller implements this interface to receive
/// DevToolsProtocolEventReceived events from the WebView.
#[com_interface("8B0DF849-2D94-47FB-8072-FE7A4D5FBA6A")]
pub trait ICoreWebView2DevToolsProtocolEventReceivedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2DevToolsProtocolEventReceivedEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive CallDevToolsProtocolMethod
/// completion results.
#[com_interface("B7627F5F-8723-4ED3-AC20-F93104CDEA51")]
pub trait ICoreWebView2CallDevToolsProtocolMethodCompletedHandler: IUnknown {
    /// Called to provide the implementer with the completion status and result
    /// of the corresponding asynchronous method call.
    unsafe fn invoke(
        &self,
        /* in */ error_code: HRESULT,
        /* in */ return_object_as_json: LPCWSTR,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the CoreWebView2Host created
/// via CreateCoreWebView2Host.
#[com_interface("E09F5D38-91E3-49D1-8182-70A616AA06B9")]
pub trait ICoreWebView2CreateCoreWebView2HostCompletedHandler: IUnknown {
    /// Called to provide the implementer with the completion status and result
    /// of the corresponding asynchronous method call.
    unsafe fn invoke(
        &self,
        result: HRESULT,
        created_host: *mut *mut ICoreWebView2HostVTable,
    ) -> HRESULT;
}

/// Event args for the NewWindowRequested event. The event is fired when content
/// inside webview requested to a open a new window (through window.open() etc.)
#[com_interface("DDBF77B3-3411-44AB-AA15-FDFC93AFFCF8")]
pub trait ICoreWebView2NewWindowRequestedEventArgs: IUnknown {
    /// The target uri of the NewWindowRequest.
    unsafe fn get_uri(&self, /* out, retval */ uri: *mut LPWSTR) -> HRESULT;

    /// Sets a WebView as a result of the NewWindowRequest. The target
    /// webview should not be navigated. If the NewWindow is set, its top level
    /// window will return as the opened WindowProxy.
    unsafe fn put_new_window(
        &self,
        /* in */ new_window: *mut *mut ICoreWebView2VTable,
    ) -> HRESULT;

    /// Gets the new window.
    unsafe fn get_new_window(
        &self,
        /* out, retval */ new_window: *mut *mut *mut ICoreWebView2VTable,
    ) -> HRESULT;

    /// Sets whether the NewWindowRequestedEvent is handled by host. If this is false
    /// and no NewWindow is set, the WebView will open a popup
    /// window and it will be returned as opened WindowProxy.
    /// If set to true and no NewWindow is set for a window.open call, the opened
    /// WindowProxy will be for an dummy window object and no window will load.
    /// Default is false.
    unsafe fn put_handled(&self, /* in */ handled: BOOL) -> HRESULT;

    /// Gets whether the NewWindowRequestedEvent is handled by host.
    unsafe fn get_handled(&self, /* out, retval */ handled: *mut BOOL) -> HRESULT;

    /// IsUserInitiated is true when the new window request was initiated through a user gesture
    /// such as clicking an anchor tag with target.
    unsafe fn get_is_user_initiated(
        &self,
        /* out, retval */ is_user_initiated: *mut BOOL,
    ) -> HRESULT;

    /// Obtain an ICoreWebView2Deferral object and put the event into a deferred state.
    /// You can use the ICoreWebView2Deferral object to complete the window open
    /// request at a later time.
    /// While this event is deferred the opener window will be returned a WindowProxy
    /// to an unnavigated window, which will navigate when the deferral is complete.
    unsafe fn get_deferral(
        &self,
        /* out, retval */ deferral: *mut *mut *mut ICoreWebView2DeferralVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive NewWindowRequested
/// events.
#[com_interface("715E10DD-2323-4F03-B6B3-AB34006B96D5")]
pub trait ICoreWebView2NewWindowRequestedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut ICoreWebView2NewWindowRequestedEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive DocumentTitleChanged
/// events. Use the DocumentTitle property to get the modified
/// title.
#[com_interface("CF313728-68BC-4577-9A35-08E660544AD9")]
pub trait ICoreWebView2DocumentTitleChangedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event. There are no event args and the args
    /// parameter will be null.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut IUnknownVTable,
    ) -> HRESULT;
}

/// Event args for the AcceleratorKeyPressed event.
#[com_interface("AF1587DD-E2FF-4BFF-8C1A-699D6D34C683")]
pub trait ICoreWebView2AcceleratorKeyPressedEventArgs: IUnknown {
    /// The key event type that caused the event to be fired.
    unsafe fn get_key_event_kind(
        &self,
        /* out, retval */ key_event_kind: *mut KeyEventKind,
    ) -> HRESULT;

    /// The Win32 virtual key code of the key that was pressed or released.
    /// This will be one of the Win32 virtual key constants such as VK_RETURN or
    /// an (uppercase) ASCII value such as 'A'. You can check whether Ctrl or Alt
    /// are pressed by calling GetKeyState(VK_CONTROL) or GetKeyState(VK_MENU).
    unsafe fn get_virtual_key(&self, /* out, retval */ virtual_key: *mut UINT) -> HRESULT;

    /// The LPARAM value that accompanied the window message. See the
    /// documentation for the WM_KEYDOWN and WM_KEYUP messages.
    unsafe fn get_key_event_lparam(&self, /* out, retval */ l_param: *mut i32) -> HRESULT;

    /// A structure representing the information passed in the LPARAM of the
    /// window message.
    unsafe fn get_physical_key_status(
        &self,
        /* out, retval */ physical_key_status: *mut PhysicalKeyStatus,
    ) -> HRESULT;

    /// During AcceleratorKeyPressedEvent handler invocation the WebView is blocked
    /// waiting for the decision of if the accelerator will be handled by the host
    /// or not. If the Handled property is set to TRUE then this will
    /// prevent the WebView from performing the default action for this
    /// accelerator key. Otherwise the WebView will perform the default action for
    /// the accelerator key.
    unsafe fn get_handled(&self, /* out, retval */ handled: *mut BOOL) -> HRESULT;

    /// Sets the Handled property.
    unsafe fn put_handled(&self, /* in */ handled: BOOL) -> HRESULT;
}

/// The caller implements this interface to receive the AcceleratorKeyPressed
/// event.
#[com_interface("253D0AA2-6F85-4FB2-9D6B-0DC5FEDBB085")]
pub trait ICoreWebView2AcceleratorKeyPressedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2HostVTable,
        /* in */ args: *mut *mut ICoreWebView2AcceleratorKeyPressedEventArgsVTable,
    ) -> HRESULT;
}

/// Event args for the NewBrowserVersionAvailable event.
#[com_interface("5A86C3E7-511B-4F99-BC20-8A8ED5449C12")]
pub trait ICoreWebView2NewBrowserVersionAvailableEventArgs: IUnknown {
    /// The browser version info of the current ICoreWebView2Environment
    unsafe fn get_new_version(&self, /* out, retval */ new_version: *mut LPWSTR) -> HRESULT;
}

/// The caller implements this interface to receive NewBrowserVersionAvailable events.
/// Use the get_NewVersion method of ICoreWebView2NewBrowserVersionAvailableEventArgs
/// to get the new version number.
#[com_interface("865E16C4-A24D-4AC1-BC23-2E608CA313F9")]
pub trait ICoreWebView2NewBrowserVersionAvailableEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event.
    unsafe fn invoke(
        &self,
        /* in */ webview_environment: *mut *mut ICoreWebView2EnvironmentVTable,
        /* in */ args: *mut *mut ICoreWebView2NewBrowserVersionAvailableEventArgsVTable,
    ) -> HRESULT;
}

/// The caller implements this method to receive the
/// ContainsFullScreenElementChanged events. There are no event args for this
/// event.
#[com_interface("EC2AF7C6-4579-40AB-8C36-5CCEE58EB7CB")]
pub trait ICoreWebView2ContainsFullScreenElementChangedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event. There are no event args and the args
    /// parameter will be null.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut IUnknownVTable,
    ) -> HRESULT;
}

/// The caller implements this interface to receive NewWindowRequested
/// events.
#[com_interface("1AE0297A-9671-4ED6-902A-4544B9B4AECD")]
pub trait ICoreWebView2WindowCloseRequestedEventHandler: IUnknown {
    /// Called to provide the implementer with the event args for the
    /// corresponding event. There are no event args and the args
    /// parameter will be null.
    unsafe fn invoke(
        &self,
        /* in */ sender: *mut *mut ICoreWebView2VTable,
        /* in */ args: *mut *mut IUnknownVTable,
    ) -> HRESULT;
}

/// This represents the WebView2 Environment. WebViews created from an
/// environment run on the Browser process specified with environment parameters
/// and objects created from an environment should be used in the same environment.
/// Using it in different environments are not guaranteed to be compatible and may fail.
#[com_interface("7dc2ec84-56cb-4fcc-b4c6-a9f85c7b2894")]
pub trait ICoreWebView2Environment: IUnknown {
    /// Asynchronously create a new WebView.
    ///
    /// parentWindow is the HWND in which the WebView should be displayed and
    /// from which receive input. The WebView will add a child window to the
    /// provided window during WebView creation. Z-order and other things impacted
    /// by sibling window order will be affected accordingly.
    ///
    /// It is recommended that the application set Application User Model ID for
    /// the process or the application window. If none is set, during WebView
    /// creation a generated Application User Model ID is set to root window of
    /// parentWindow.
    /// \snippet AppWindow.cpp CreateCoreWebView2Host
    ///
    /// It is recommended that the application handles restart manager messages
    /// so that it can be restarted gracefully in the case when the app is using
    /// Edge for webview from a certain installation and that installation is being
    /// uninstalled. For example, if a user installs Edge from Dev channel and
    /// opts to use Edge from that channel for testing the app, and then uninstalls
    /// Edge from that channel without closing the app, the app will be restarted
    /// to allow uninstallation of the dev channel to succeed.
    /// \snippet AppWindow.cpp RestartManager
    unsafe fn create_core_web_view2_host(
        &self,
        parent_window: HWND,
        handler: *mut *mut ICoreWebView2CreateCoreWebView2HostCompletedHandlerVTable,
    ) -> HRESULT;

    /// Create a new web resource response object. The headers is the
    /// raw response header string delimited by newline. It's also possible to
    /// create this object with empty headers string and then use the
    /// ICoreWebView2HttpResponseHeaders to construct the headers line by line.
    /// For information on other parameters see ICoreWebView2WebResourceResponse.
    ///
    /// \snippet SettingsComponent.cpp WebResourceRequested
    unsafe fn create_web_resource_response(
        &self,
        /* in */ content: *mut *mut IStreamVTable,
        /* in */ status_code: i32,
        /* in */ reason_phrase: LPCWSTR,
        /* in */ headers: LPCWSTR,
        /* out, retval */ response: *mut *mut *mut ICoreWebView2WebResourceResponseVTable,
    ) -> HRESULT;

    /// The browser version info of the current ICoreWebView2Environment,
    /// including channel name if it is not the stable channel.
    /// This matches the format of the GetCoreWebView2BrowserVersionInfo API.
    /// Channel names are 'beta', 'dev', and 'canary'.
    ///
    /// \snippet AppWindow.cpp GetBrowserVersionInfo
    unsafe fn get_browser_version_info(
        &self,
        /* out, retval */ version_info: *mut LPWSTR,
    ) -> HRESULT;

    /// The NewBrowserVersionAvailable event fires when a newer version of the
    /// Edge browser is installed and available to use via WebView2.
    /// To use the newer version of the browser you must create a new
    /// environment and WebView.
    /// This event will only be fired for new version from the same Edge channel
    /// that the code is running from. When not running with installed Edge,
    /// no event will be fired.
    ///
    /// Because a user data folder can only be used by one browser process at
    /// a time, if you want to use the same user data folder in the WebViews
    /// using the new version of the browser,
    /// you must close the environment and WebViews that are using the older
    /// version of the browser first. Or simply prompt the user to restart the
    /// app.
    ///
    /// \snippet AppWindow.cpp NewBrowserVersionAvailable
    ///
    unsafe fn add_new_browser_version_available(
        &self,
        /* in */
        event_handler: *mut *mut ICoreWebView2NewBrowserVersionAvailableEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with add_NewBrowserVersionAvailable.
    unsafe fn remove_new_browser_version_available(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;
}

/// The caller implements this interface to receive the WebView2Environment created
/// via CreateCoreWebView2Environment.
#[com_interface("7ED79562-90E1-47CD-A4E0-01D9211D7E3D")]
pub trait ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler: IUnknown {
    /// Called to provide the implementer with the completion status and result
    /// of the corresponding asynchronous method call.
    unsafe fn invoke(
        &self,
        result: HRESULT,
        created_environment: *mut *mut ICoreWebView2EnvironmentVTable,
    ) -> HRESULT;
}

/// A Receiver is created for a particular DevTools Protocol event and allows
/// you to subscribe and unsubsribe from that event.
/// Obtained from the WebView object via GetDevToolsProtocolEventReceiver.
#[com_interface("13FC668D-1F6D-4955-A4F4-D1EE7DEB5B74")]
pub trait ICoreWebView2DevToolsProtocolEventReceiver: IUnknown {
    /// Subscribe to a DevToolsProtocol event.
    /// The handler's Invoke method will be called whenever the corresponding
    /// DevToolsProtocol event fires. Invoke will be called with the
    /// an event args object containing the DevTools Protocol event's parameter
    /// object as a JSON string.
    ///
    /// \snippet ScriptComponent.cpp DevToolsProtocolEventReceived
    unsafe fn add_dev_tools_protocol_event_received(
        &self,
        /* in */
        handler: *mut *mut ICoreWebView2DevToolsProtocolEventReceivedEventHandlerVTable,
        /* out */ token: *mut EventRegistrationToken,
    ) -> HRESULT;

    /// Remove an event handler previously added with
    /// add_DevToolsProtocolEventReceived.
    unsafe fn remove_dev_tools_protocol_event_received(
        &self,
        /* in */ token: EventRegistrationToken,
    ) -> HRESULT;
}
